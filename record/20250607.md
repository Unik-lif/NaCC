## 实验记录
仔细看了一下OpenSBI的ecall的调用位置，基本上还是放在trap handler中来接收新的请求，看起来penglai也是这么干的

之后我们需要探索一下Agent启动和qemu上的一些设置，我们最好还是参考penglai的脚本来做适配，首先我们想办法利用docker搭建一个合适的环境，然后再逐步来进行工作

或者我们不使用docker，但是在搭建环境的时候努力采用脚本来做，这样可以在传递某些环境变量的时候保持安全，干净，和便利

最终我还是尝试跑通了riscv-gnu-linux那条工具链，把buildroot对应的rootfs.ext2跑通了，但是还是很慢，不符合我的感官。

当然似乎可持久性上好像还有一点问题，还需要确认一下

持久性确实有一点问题，我感觉buildroot搭建的rootfs还是太小儿科了，很有可能没办法支持我们在内部的文件系统里头，再跑起来一个docker来做测量

看起来，我们需要搞一个类似全系统的东西，需要有正儿八经的磁盘使得我们跑的起来大的应用，就像做NestedSGX一样

虽然可能会加入一些ubuntu系统的干扰，但或许最后的结果也不坏？

我做了一些尝试，发现这件事情并不容易，我们需要在持久化硬件上做，因此参照buildroot的方式反而不见得好，虽然buildroot最终的方案可能还是通过使用一个发行版来做，也就是我们可能还是倾向于使用ubuntu磁盘的方式来弄，我们需要依赖ubuntu本身的生态，这件事情似乎还是很重要的

为了生态考虑可能直接在嵌入式场景跑docker不是特别合适？

https://github.com/carlosedp/riscv-bringup/tree/master/Qemu#building-the-qemu-vm-image

我思考了以下，似乎原来的方案只能用来做初步试验，就工业级标准来看确实也不够

姑且按照这边的指引来做吧

and和蓬莱不同，我就只有一个人做这个大项目，我不想写SDK，写完SDK还要去移植redis和golang，最后还要跑起来docker和里头的docker benchmark，想想就头大，如果可以用gcc生态等支持我在发行版中跑起来应用就行

发行版能帮我编起来文件系统就行？似乎上面的链接也是直接下载linux的内核跑起来机器，我觉得似乎是可行的

此外做全系统的事情不是我一个人能够搞定的，别人可是有一个团队呢，我光别人的buildroot这边的脚本是怎么裁剪出来，都觉得非常震撼，麻蛋我不知道这是怎么裁剪出来的，以后有机会一定问问看