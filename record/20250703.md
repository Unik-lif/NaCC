## 实验记录
落实一下昨天设计好的内存分配方案。
```
git submodule update --init --recursive
```
让boot hart去对内存区域做好对应的初始化，包括PMP的设置，metadata区域的初始化和设置，以及bitmap范围的设置

把xv6的物理内存分配方式写了一下，移植了一下，不是特别麻烦

目前已经通过了多核的测试，看起来没啥问题

花了一些时间去搞清楚多核的事情，其实主要就抓住两个原则就行，剩下就很简单：
- do_once需要特地写一下，这部分opensbi中有实现的逻辑，可以参考
- spin_lock在opensbi中也有实现，如果使用同一块资源，需要同步，需要多使用spin_lock来做

下一步，可能可以同步着做
- 阅读qemu的源码，添加bitmap相关联的寄存器，将检查的逻辑放到硬件中去。然后还可以加上reg_cpu_state寄存器
- 实现opensbi的搬运，我们先前实现了基于satp的页表打印，现在要考虑分配内存区域，把页表页写到PMP区域中，并想办法通过某种方式组织起来，当然这件事可能不是特别复杂，但我很好奇在搬运之后，是否还能正常地去跑docker run hello-world

晚上思考的时候发现在内存的规划上还是欠考虑，内存应该有很多种类型，我们的好处是，页表永远都是同一个，开销不是特别大，下面是我们的设计目标，以及因此需要特地开辟出来的内存区域：
- agent和host os进行共享时需要依赖一块共享内存用来传递系统调用的参数值，这块区域应该是host os事先通过某个协议决定分配出来的
- Agent区域可能还是放在S-mode可以读写的PMP区域中，但是如果对这个区域要访问或者读，需要还能满足reg_cpu_state的设置，因此初始状态下，我们还需要将其放到M mode区域，直到设置好了reg_cpu_state，准备跑起来agent时，再修改PMP config寄存器
- Secure Monitor的一些动态分配，和管理Linux bitmap的数据结构，即metadata区域，理应对Agent和Host OS都不可见，这一个区域可能还是要用
- 地址翻译MMU默认是在S-mode的，因此保护起来的页表页也得让S-mode可见，不过显然是不能改的

那么我们还是要再做一次拆分