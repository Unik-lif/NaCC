## 实验记录
首先我们尝试直接跳转到agent所在的区域中，这边agent会对其的栈内容做初始化，并再打印一些标志说明自己已经被初始化了

先得彻底搞清楚中断异常相关的寄存器和对应的流程

### 先看mstatus寄存器
- MIE和SIE，分别给Machine和Supervisor mode中对于interrupt handlers来使用，保证处理的原子性
- xIE = 1时，当hart跑在x mode下，此时中断能被enable。当xIE = 0，hart跑在x mode下，此时没有中断
- 当xIE = 1被设置时，y mode如果有中断，如果y > x，则无论yIE是否被设置，都能捕获到中断。反之若y < x，则无法捕获到中断
- xPIE，表示prior interrupt enable，里头存放着在trap发生之前，xIE中的内容。xPP，则表示prior privilege，里头存放着发生trap之前对应的权限mode
- xPP中只能存放不超过x的权限级，因此在mstatus中，我们可以看到MPP中有两个bit，而SPP中只有一个bit的位置，注意，这边是trap的进入流程

当trap发生的时候，假设我们从y跑到x mode，那么xPIE将会被设置成xIE的值，由于现在需要在x mode处理trap，所以xIE很自然也会被设置成0，xPP将会被设置成y

当MRET或者SRET发生的时候，xRET指令在跑的时候，xPP将会拿到y值，xIE将会被设置成xPIE，这就表示切换回到了y这个权限mode上。此外，xPIE将会被设置成1，其实就是表示在之前，这个中断发生了，因此xPIE应该得是1，才能反映先前xIE的中断能够被正确触发并捕获的这个过程。返回之后xPP将会被设置成least-privileged supported mode，也就是最小的权限级

感觉在xRET发生之后，在读完xPP和xPIE中的值后，对于xPP和xPIE值的设置，倒不如说是某种约定俗成

xPIE的关键：给xIE一个暂时存放的地方，因为在处理trap的时候，需要把中断关掉，xIE不可避免地会在0和原来的值中反复横跳，而xPIE让它能够可以反复横跳

### Delegation
当某个trap被下放到S-mode中时，scause寄存器中将会有trap cause，sepc寄存器中会有触发trap的instruction所对应的虚拟地址，stval寄存器中将会有excpetion-specific datum，也就是异常所特定存放的值

重点来了，此时mstatus寄存器中的SPP位将会存放trap发生时的privilege mode，那么不用想只能是S mode或者U mode。SPIE则会写原本SIE的值，SIE位置则会被清空，这样就不会被其他中断所干扰。M mode处理异常的寄存器，包括mcause,mepc,mtval等，以及MPP和MPIE位置，则不会被写

trap永远从低处往高处走，维持同级倒是可能的

### Trap Entry and Trap Return
看了上面的内容后，似乎这边不难理解了，我们直接开始做
