## 实验记录
我们得尝试把中断处理vector给它设置好

我们参考了xv6-riscv，这个做的比较简单，看看就好

然后再看linux怎么做这个
```C
// 在这里要做handle_exception，把它加载到了CSR_TVEC位置上
.align 2
.Lsetup_trap_vector:
	/* Set trap vector to exception handler */
	la a0, handle_exception
	csrw CSR_TVEC, a0

	/*
	 * Set sup0 scratch register to 0, indicating to exception vector that
	 * we are presently executing in kernel.
	 */
	csrw CSR_SCRATCH, zero
	ret

// 函数handle_exception
SYM_CODE_START(handle_exception)
	/*
	 * If coming from userspace, preserve the user thread pointer and load
	 * the kernel thread pointer.  If we came from the kernel, the scratch
	 * register will contain 0, and we should continue on the current TP.
	 */
    // 如果请求来自于userspace，则通过scratch寄存器指向的位置来存放用户的上下文
    // scratch是否有值，直接能够决定我们的异常来源到底是kernel mode还是user mode
	csrrw tp, CSR_SCRATCH, tp
	bnez tp, .Lsave_context

    // 如果异常是来自于kernel mode的
    // 当然，在agent这边，我们会让agent自己不会产生异常
    // linux出了异常，也需要能够妥善的进行管理
.Lrestore_kernel_tpsp:
    // 这边是把tp的值从scratch寄存器中恢复起来
	csrr tp, CSR_SCRATCH

#ifdef CONFIG_64BIT
	/*
	 * The RISC-V kernel does not eagerly emit a sfence.vma after each
	 * new vmalloc mapping, which may result in exceptions:
	 * - if the uarch caches invalid entries, the new mapping would not be
	 *   observed by the page table walker and an invalidation is needed.
	 * - if the uarch does not cache invalid entries, a reordered access
	 *   could "miss" the new mapping and traps: in that case, we only need
	 *   to retry the access, no sfence.vma is required.
	 */
	new_vmalloc_check
#endif

	REG_S sp, TASK_TI_KERNEL_SP(tp)

#ifdef CONFIG_VMAP_STACK
	addi sp, sp, -(PT_SIZE_ON_STACK)
	srli sp, sp, THREAD_SHIFT
	andi sp, sp, 0x1
	bnez sp, handle_kernel_stack_overflow
	REG_L sp, TASK_TI_KERNEL_SP(tp)
#endif

// 这边存放来自用户的上下文信息
.Lsave_context:
    // 在Linux给用户开设的task_struct中，分别存放了kernel_sp和user_sp，用来放上下文信息
    // OFFSET(TASK_TI_KERNEL_SP, task_struct, thread_info.kernel_sp);
	// OFFSET(TASK_TI_USER_SP, task_struct, thread_info.user_sp);
    // 读取kernel_sp，然后现在拿过来进行使用，其中PT_SIZE_ON_STACK对应的事pt_regs这么大空间的寄存器
    // 主要是一些通用寄存器信息
	REG_S sp, TASK_TI_USER_SP(tp)
	REG_L sp, TASK_TI_KERNEL_SP(tp)
	addi sp, sp, -(PT_SIZE_ON_STACK)
    // sp就是x2寄存器，tp是x4寄存器，这两个可能得最后恢复，因为我们现在还在使用sp
	REG_S x1,  PT_RA(sp)
	REG_S x3,  PT_GP(sp)
	REG_S x5,  PT_T0(sp)
	save_from_x6_to_x31

	/*
	 * Disable user-mode memory access as it should only be set in the
	 * actual user copy routines.
	 *
	 * Disable the FPU/Vector to detect illegal usage of floating point
	 * or vector in kernel space.
	 */
	li t0, SR_SUM | SR_FS_VS
    // 这边在tp指向的scratch中，才存放着真正的用户所使用的sp
    // 之后这边还读取了一些用户态中状态寄存器的信息
	REG_L s0, TASK_TI_USER_SP(tp)
	csrrc s1, CSR_STATUS, t0
	csrr s2, CSR_EPC
	csrr s3, CSR_TVAL
	csrr s4, CSR_CAUSE
	csrr s5, CSR_SCRATCH
	REG_S s0, PT_SP(sp)
	REG_S s1, PT_STATUS(sp)
	REG_S s2, PT_EPC(sp)
	REG_S s3, PT_BADADDR(sp)
	REG_S s4, PT_CAUSE(sp)
	REG_S s5, PT_TP(sp)

	/*
	 * Set the scratch register to 0, so that if a recursive exception
	 * occurs, the exception vector knows it came from the kernel
	 */
	csrw CSR_SCRATCH, x0

	/* Load the global pointer */
	load_global_pointer

	/* Load the kernel shadow call stack pointer if coming from userspace */
	scs_load_current_if_task_changed s5

#ifdef CONFIG_RISCV_ISA_V_PREEMPTIVE
	move a0, sp
	call riscv_v_context_nesting_start
#endif
	move a0, sp /* pt_regs */

	/*
	 * MSB of cause differentiates between
	 * interrupts and exceptions
	 */
    // 利用Most Significant Bit来，s4又是cause存放的地方
    // 以此来判断到底是do_irq，还是exceptions
    // 因此这样分成了两个部分
	bge s4, zero, 1f

	/* Handle interrupts */
	call do_irq
	j ret_from_exception
1:
	/* Handle other exceptions */
    // 从这边已经构建好的excp_vect_table中，利用s4中的值，选择对应的表项
    // 相加得到需要处理的异常类型
    // 见下面的内容，这确实是一种非常高明的中断注册方法
	slli t0, s4, RISCV_LGPTR
	la t1, excp_vect_table
	la t2, excp_vect_table_end
	add t0, t1, t0
	/* Check if exception code lies within bounds */
	bgeu t0, t2, 3f
	REG_L t1, 0(t0)
2:	jalr t1
	j ret_from_exception
3:

	la t1, do_trap_unknown
	j 2b
SYM_CODE_END(handle_exception)

	.section ".rodata"
	.align LGREG
	/* Exception vector table */
SYM_DATA_START_LOCAL(excp_vect_table)
	RISCV_PTR do_trap_insn_misaligned
	ALT_INSN_FAULT(RISCV_PTR do_trap_insn_fault)
	RISCV_PTR do_trap_insn_illegal
	RISCV_PTR do_trap_break
	RISCV_PTR do_trap_load_misaligned
	RISCV_PTR do_trap_load_fault
	RISCV_PTR do_trap_store_misaligned
	RISCV_PTR do_trap_store_fault
	RISCV_PTR do_trap_ecall_u /* system call */
	RISCV_PTR do_trap_ecall_s
	RISCV_PTR do_trap_unknown
	RISCV_PTR do_trap_ecall_m
	/* instruciton page fault */
	ALT_PAGE_FAULT(RISCV_PTR do_page_fault)
	RISCV_PTR do_page_fault   /* load page fault */
	RISCV_PTR do_trap_unknown
	RISCV_PTR do_page_fault   /* store page fault */
SYM_DATA_END_LABEL(excp_vect_table, SYM_L_LOCAL, excp_vect_table_end)
```
Linux这边的handler，除了尝试解决来自user的异常，也需要努力尝试解决来自于s mode的异常，相比之下，我们做的handler应该不会这么复杂，但我们确实需要尝试复用这边的代码

为此，我们可能需要在Agent这边对齐中断处理的接口

下面是Q&A
```
我的问题：

现在，为了让我的系统更加安全，我需要在Agent这边设置中断处理入口，我的想法大体上是下面这样
1. 由于我们主要立足的部分是让Agent管理共享内存，因此，对于涉及mmap共享内存的系统调用，我们会希望让Agent自己来做系统调用的处理
2. 而对于其他类型的系统调用和其他异常情况，我们会让Agent转发信息给Linux，让Linux代为处理

现在我的问题是，看起来这么一来我需要在Agent这边的中断处理位置，在保存好机密容器user mode上下文信息的同时，与Linux这边处理异常的代码逻辑对接上

我看到Linux这边对于exception的处理事这样的：
	.section ".rodata"
	.align LGREG
	/* Exception vector table */
SYM_DATA_START_LOCAL(excp_vect_table)
	RISCV_PTR do_trap_insn_misaligned
	ALT_INSN_FAULT(RISCV_PTR do_trap_insn_fault)
	RISCV_PTR do_trap_insn_illegal
	RISCV_PTR do_trap_break
	RISCV_PTR do_trap_load_misaligned
	RISCV_PTR do_trap_load_fault
	RISCV_PTR do_trap_store_misaligned
	RISCV_PTR do_trap_store_fault
	RISCV_PTR do_trap_ecall_u /* system call */
	RISCV_PTR do_trap_ecall_s
	RISCV_PTR do_trap_unknown
	RISCV_PTR do_trap_ecall_m
	/* instruciton page fault */
	ALT_PAGE_FAULT(RISCV_PTR do_page_fault)
	RISCV_PTR do_page_fault   /* load page fault */
	RISCV_PTR do_trap_unknown
	RISCV_PTR do_page_fault   /* store page fault */
SYM_DATA_END_LABEL(excp_vect_table, SYM_L_LOCAL, excp_vect_table_end)
看起来定义了很多异常处理函数的接口，与此同时还以struct pt_regs作为参数，也就是用户上下文信息作为参数来进行处理

此外，除了异常处理，在中断处理这边，Linux还有一个do_irq处理，也以用户上下文信息regs作为参数，

我应该怎么撰写agent这边的中断异常处理？在能够满足我防护用户上下文信息的同时，正常转发部分请求给Linux，让Linux来处理，而且还能在部分系统调用的时候，如mmap，让agent有能力对于部分情况自行处理呢？

回答：

你当前的系统目标是：让Agent位于S-mode接管部分系统调用（比如 mmap）的处理权，同时对于无法自行处理的系统调用或异常，转发给S-mode的Linux来处理，并确保用户态上下文的安全保存与恢复。

要实现这个目标，你需要在Agent中构建一个类似于Linux do_trap_* 机制的异常和中断处理框架。下面是分步骤的设计方案：

一、Agent 中断/异常处理框架设计目标
Agent 有自己的 stvec 指向 Agent Trap Handler

Agent Trap Handler：

保存用户态上下文（user mode trap frame）

判断 trap 类型（系统调用/异常/中断）

决定自己处理还是转发给 Linux

如果自己处理：

分发系统调用号（通过 a7）给 Agent 的 syscall 表

如果转发给 Linux：

设置好 Linux 的 trap frame 和环境

切换上下文跳转给 Linux

最终都能回到用户态继续执行
```

## 思考
我们一步一步来，这个任务其实一点都不容易

### 对接问题
首先，我们需要在Agent这边和Linux能够对接起来，为此，我需要在一个合适的地方，妥善地管理来自user的上下文信息。

这个问题我们可以解决，我已经在Agent这边制定好了物理内存分配的代码。agent并不需要处理调度的问题，因此在初始化的时候，就开一个页来接收用户的上下文信息，此处要用和linux一致的数据结构

### 上下文存储
Agent的转发，本质上并不是切换什么状态，由于页表是同一张，可以尝试直接去调用Linux对于这些异常的处理函数来做

这件事情会比较handy，而且开销看起来似乎还比较低？

### 调度问题
agent不需要拥有调度功能，但是stvec需要能够及时地去做更改，因为linux可以对机密容器进程的执行做一些调度

当调度发生时，satp的值必然发生改变，写satp值时，硬件上最好能够实现连锁带动nacc_state寄存器的更新，以及stvec值的切换

短期内这件事情可以通过构造一个trap，让opensbi来做，未来我们如果希望加速，就需要把这个部分的切换做好对齐处理，然后全部放到硬件上去

stvec必须要在satp切换的时候同步发生改变，而且还不能允许在nacc_state上有值的时候，让Linux对这个寄存器做修改

### 系统调用分类问题
有很多请求是需要拆分，然后进入不同的控制链路中去的，在存储了这一部分信息之后，如果是do_trap_ecall_u类型，在进入Linux OS函数时，先自己看一眼参数

## 其他
和老师讨论了一下，方案已经明确，明天主要做实现

晚上自己开始去看serverless领域的文章，这个领域看起来还挺有意思的，希望能够以此做点事情了，当然，我还需要再看点分布式的内容