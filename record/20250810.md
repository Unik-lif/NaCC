## 实验记录
找到了添加acall和aret指令的入口和操作方式

我们不希望它们触发异常，而是像正常的mret或者sret，直接在agent和linux之间做切换一些寄存器状态就行

与此同时，可能需要在一些寄存器中，储存之后跳转的入口

我们不希望和其他已有的寄存器产生干扰

梳理一下这个流程
- 当用户进程发生了系统调用或者异常之后，被agent先进行一个捕获
- agent并不需要维持linux的上下文信息，我们只需要切换到Linux的状态，然后跑起来我们的handler
- 我们会利用acall来进入到linux的handler中，我们可能需要在ra中存放下一条指令的pc地址
- 我们可以在a0寄存器中，存放我们需要跳转到的虚拟地址，这个虚拟地址应该事先可以由agent得到
- 跳转到各自的handler函数之后，根据nacc_state的值，来确定是否需要通过aret来返回
- aret将会返回到ra存放的地方，也就是跳转回原来的位置，同时修改nacc_state寄存器的值
- user的上下文信息需要先由agent做一个备份，然后再尝试在一个linux可以访问的位置做好共享

