## 实验记录
找到了添加acall和aret指令的入口和操作方式

我们不希望它们触发异常，而是像正常的mret或者sret，直接在agent和linux之间做切换一些寄存器状态就行

与此同时，可能需要在一些寄存器中，储存之后跳转的入口

我们不希望和其他已有的寄存器产生干扰

梳理一下这个流程
- 当用户进程发生了系统调用或者异常之后，被agent先进行一个捕获
- agent并不需要维持linux的上下文信息，我们只需要切换到Linux的状态，然后跑起来我们的handler
- 我们会利用acall来进入到linux的handler中，我们可能需要在ra中存放下一条指令的pc地址
- 我们可以在a0寄存器中，存放我们需要跳转到的虚拟地址，这个虚拟地址应该事先可以由agent得到
- 跳转到各自的handler函数之后，根据nacc_state的值，来确定是否需要通过aret来返回
- aret将会返回到ra存放的地方，也就是跳转回原来的位置，同时修改nacc_state寄存器的值
- user的上下文信息需要先由agent做一个备份，然后再尝试在一个linux可以访问的位置做好共享

拒绝stvec寄存器被smode下的Linux所修改，其他可能允许修改之

```Shell
In file included from ../target/riscv/translate.c:1153:
../target/riscv/insn_trans/trans_privileged.c.inc: In function ‘trans_acall’:
../target/riscv/insn_trans/trans_privileged.c.inc:77:5: error: implicit declaration of function ‘gen_helper_acall’; did you mean ‘gen_helper_csrw’? [-Werror=implicit-function-declaration]
   77 |     gen_helper_acall(cpu_pc, tcg_env);
      |     ^~~~~~~~~~~~~~~~
      |     gen_helper_csrw
../target/riscv/insn_trans/trans_privileged.c.inc:77:5: error: nested extern declaration of ‘gen_helper_acall’ [-Werror=nested-externs]
../target/riscv/insn_trans/trans_privileged.c.inc: In function ‘trans_aret’:
../target/riscv/insn_trans/trans_privileged.c.inc:88:5: error: implicit declaration of function ‘gen_helper_aret’; did you mean ‘gen_helper_brev8’? [-Werror=implicit-function-declaration]
   88 |     gen_helper_aret(cpu_pc, tcg_env);
      |     ^~~~~~~~~~~~~~~
      |     gen_helper_brev8
../target/riscv/insn_trans/trans_privileged.c.inc:88:5: error: nested extern declaration of ‘gen_helper_aret’ [-Werror=nested-externs]
cc1: all warnings being treated as errors
[2306/2678] Compiling C object libqemu-riscv64-softmmu.a.p/target_riscv_translate.c.o
```
这个问题让我卡住了，我觉得很奇怪

解决了，是宏定义的问题，以及寄存器用的名字搞错了

到今天为止，所有我觉得重要的硬件上的修改我感觉都做的差不多了，明天我会把重点放在trap handler在agent这边的实现上，说起来确实这件事情不容易，硬件上的改动还是挺多的