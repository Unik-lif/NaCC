## 实验记录
我们需要让kmem的物理内存的分配机制，在linux的页表中也有效果，这件事情感觉有点复杂

在启用linux的页表之前，我们只会使用kfree来组织起来内存

在物理内存中似乎呈现出来下面的这个效果

```
AGENT_REGION_END  => .... => eagent
      |__________|
```
他们物理地址中，开始的八位需要写上对于下一个物理地址内存块所对应的物理地址

在开启了linux的页表之后，我们会使用kalloc来分配内存，也可能会使用kfree来进行内存的释放

```C
/*
 * Only be used after the 'satp' is set to the linux one.
 */
void* kalloc(void)
{
    struct run *r;

    r = kmem.freelist - _offset;
    if(r)
        kmem.freelist = r->next;

    return (void*)r;
}
```
kalloc的使用应该是每一次拿到了kmem.freelist之后，先让他减去一个_offset，这样得到的r就能指向正确的虚拟地址位置

后续kfree的使用应该也需要做调整，为了保证最后的语义是一致的，在linux对应的satp开启之后，kfree中我们会尝试传递va，而不使用pa

但是维持pa的检查范围
```C
/*
 * Only be used after the 'satp' is set to the linux one.
 */
void kfree(void *va)
{
    struct run *r;

    uint64 pa = (uint64) va + _offset;
    if((pa % PGSIZE) != 0 || pa < (uint64) eagent || pa >= SBI_DOMAIN_AGENT_REGION_END)
        printf("kfree");

    r = (struct run*) va;

    r->next = kmem.freelist;
    
    kmem.freelist = (void *) pa;
}
```