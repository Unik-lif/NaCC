## 实验记录
我尝试让agent直接去修改linux对应的大页表，似乎不大顺利

后来我在提问的时候才意识到，agent的物理内存应该就是给自己用，不要拿去公用，即不要拿去当作Page Table Page

下面的这个是我的问题
```
我现在遇到了一个问题 我还是在推进我的NaCC项目，现在打算在agent这边做一个trap handler出来 但是我遇到了下面的问题，让我觉得有点棘手 在agent初始化的时候，因为我需要通过页表trampoline，我需要建立临时页表，用来对接上linux的页表，这件事情我做好了。为了做这个页表，我对agent空间的物理地址采用链表来进行分配和组织。这个物理内存的分配器，我是在页表还没有开启的时候，在agent这边制作的，因此物理地址分配器中的地址信息，纷纷指向物理地址的值 但是当我终于切换到linux的页表中后，我的agent其实并没有把初始化跑完，为此我需要准备trap frame，也就是尝试分配一块物理内存拿去用，但是由于此时linux的页表已经切换过来，原本我写到物理内存分配器中的物理地址，就似乎有些失效了，我如果需要能够成功访问这些地址区域，至少需要做到两点 1. 我需要能够在linux的页表中，有这样的页表映射 2. 我需要维持好这边的agent地址的虚拟地址和物理地址的偏移 因此，我尝试在agent这边，对linux的页表做修改，添加我所需要的地址映射，但是这件事情在agent的视角，也就是开启了页表机制的情况下，似乎不是那么容易 而且如果是把agent区域的物理内存，拿去当作页表项来使用，不仅仅是分配，访问上似乎也有点奇怪 你觉得我应该怎么做呢？是不是得让agent尝试对linux的页表做修改时，发送个请求给opensbi这边来去修改？这样比较合适，也似乎更加符合我们一开始的安全构思？ 然后，agent的物理地址空间中的物理地址，我们不会让他去扮演页表项 这样会不会更加合适？
```

确实忘记了，任何涉及页表上的user part的改动，按照我们的设计，应该得尝试去发一个请求给opensbi来做，这也许是唯一可行的办法，也是最为中正的方法

那么如果要修改映射，我们不应该再尝试在agent这边做了，而是直接在sbi中加一个请求


解决了这个问题，好！

之后调试trap handler去，这边还有一些硬件细节需要debug～！