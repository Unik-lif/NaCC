## 实验记录
搞清楚为什么我们新添加的指令不被opensbi所接受，并触发了异常情况

所以这个听起来像是riscv本身的各个指令在编码的时候有一些特殊的类型，然后我这个无意进入了他们的一种类型，而他们这种类型有一些特殊的规范，我没有遵守，导致这个指令没有办法被识别出来是吗？

好像确实，看了一下手册，我们确实误入SYSTEM类型的指令了

其中有一些custom类型的指令，也许可以拿来使用

custom-0: 0001011

好像没有之前的那个报错了，但是疑似是nacc_state寄存器的值没有被好好设置，被qemu拒绝了

看一下qemu如何打印信息

进去agent的时候，nacc_state中是agent状态

从agent离开之后，也许并不需要完全把agent和opensbi分开来，但是linux和agent之间一定要分开来

现在的问题是从agent进入到linux后，linux的状态需要切换一下，我们直接修改riscv_cpu_set_mode这边的逻辑

然后，我们看看能不能把断点打到linux中，看看效果，确实回到了应该的位置上，那就说明没有问题

检查当前的linux的权限是否是合适的
1. 对于agent区域是否有能力进行访问？

奇怪的问题
- 似乎linux在ecall结束前，进入了一次agent所对应的__trap_entry，这非常奇怪，我甚至连这个为什么会发生都觉得很诡异

我觉得很奇怪的现象又出来了一个新的 为了初始化agent，我们先从linux这边调用ecall进入到opensbi这边，然后opensbi保存好linux的上下文和中断信息后，进入到agent，agent初始化并且做好trap_entry的设置后，回到opensbi，sbi进而利用mret尝试回到linux。 但是在mret发生之后，不知道为什么我们的程序跳转到了agent所设置的trap_entry位置 这让我非常奇怪