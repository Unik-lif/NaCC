## 实验记录
先尝试把vector关掉

其他的步骤，包括转发异常用来做处理似乎都是正常的，但是很奇怪的地方在于nacc_state寄存器的值出现了波动，就像是硬件上改动了nacc_state的状态为agent，但是软件上其实还没有来得及跳转到处理异常的agent位置上，而是继续往下走，走完了原本mret要返回的那一个过程

超级奇怪的现象，当我disable了中断异常，这个时候没有时钟异常了，nacc_state的值稳定了下来，但是时钟中断似乎是异步的，只要我重新enable了sstatus寄存器，它就会重新开始尝试干扰我的state值，看起来只要有异步的时钟还在处理，我们的state位置就很有可能是agent值

你的意思其实是？由于异步异常只要被时钟触发，就会在硬件上进入到这个逻辑，因此即便软件上我们还在linux正常运行的这边，甚至完全还没有跑到时钟中断位置，但是硬件上的修改已经落实下来了？

所以你的意思是？想办法把最表层的硬件操作解耦开来？至少不要让linux还在运行在正常流程中，即还没有尝试触发时钟中断的时候，就把硬件上的Agent状态改动过来？

那么如果要做到这一点，听起来有点困难，这意味着我似乎不能在尝试跳转到stvec位置的时候，直接把状态调整为agent，而是先尝试直接跳转到stvec后，如果遇到异常，再尝试调整状态为agent？

这件事情很难，但是我已经看到原因了！