## 实验记录
得想清楚如何从Linux这边干净地跳转回去，而不更改原本的其他进程执行的一些逻辑情况

关键路径：
- 正常进程，且调度时不会有机密容器进程：正常走Linux路径，不经过Agent
- 正常进程，且调度时有机密容器进程：正常走Linux路径，不经过Agent
- 机密进程：走Agent，不经过Linux

区分方式：
- 机密进程下：nacc_state中是有值的
- 正常进程：nacc_state中是没有值的

但是对于linux来说，我们希望让其看到进程的时候没有办法去查看具体的nacc_state值，因此我们不能通过这个来判断，所以关键就落实到了，应该如何操作，才能在调度的时候，看到一些特殊的参数，然后调用某些特定的指令才能实现

在task_struct参数中新添加的参数，为什么做不了假？
- 哪怕添加上了，地址空间中也没有对应的agent页，没法利用特殊指令跳转
- 被添加上了标志的进程，我们默认其地址空间中有对应的agent页，可以通过特殊指令跳转到该位置

对于切换，主要还是看switch_to这个函数，里头对于tp寄存器上的一些变动就显得比较关键了
- tp寄存器主要存放的是task_struct数据结构体的位置，这让我比较惊讶
- 切换进程和线程的本质是task_struct的切换，也就是tp的切换
- 对于task_struct中内容的访问基于tp作为基地址

因此，为了达到我们的目的，我们需要在task_struct中额外加一个域，负责区分机密容器进程
- 如我们所述，这个东西本身并不能由linux来随便改，改了意义也不大，反正之后一定会被拦截到
- 如果linux把机密容器的这个域给他清空，则之后调度的时候，nacc_state也没有正确的值，那么因此无法访问agent和user区域的地址（毕竟做了加密），当发生中断异常时，就会进入到linux这边，但是agent区域linux无法访问，而user区域linux无法做访问？（这点待定，可能得回顾一下资料修正明确一下）