## 实验记录
最核心的函数应该是__schedule，linux所有的调度最后似乎都会落实到这边

__schedule
    - context_switch
        - switch_to
        - finish_task_switch

新进程通过fork创建的时候，会跳转到ret_from_fork位置

在switch_to这边，可以加上我们对于机密容器进程的特殊处理，检测到其为机密容器进程（即对应的task_struct中有特殊标志时）的时候，通过特殊指令将自身升格
- nacc_state的信息对于linux是不可见的，不能读，也不能改

感觉还没有想清楚，先把非调度的情况想清楚

我们目前对于机密容器进程，让他能够在do_irq的时候完成请求，但是需要从linux这边跳转回去到agent位置上
- 需要在do_irq的位置上，额外加上一行命令，让其能够跳转到我们先前存放twin_entry寄存器对应的PC位置上
- 但是必须要做到一个基本的区分，就是当前的这个task_struct，是否是机密容器，如果是，我们才会跳转，如果不是，我们就不跳转回去
- 这件事情需要通过检查tp对应的task_struct来得到

如果linux冒充某个普通进程为机密进程，并尝试调度它
- 虽然nacc_state状态同样切换过来了，似乎就权限上能够去访问bitmap区域了，但是没有真正在页表中有机密容器对应的页
- 然而，twin_entry等关键寄存器存在被篡改的风险，进而破坏机密容器进程出现trap时跳转到的位置
- 因此，在context_switch位置，得强制加上一个ecall陷入到opensbi这边做好检查

从do_irq这边跳回：
- 