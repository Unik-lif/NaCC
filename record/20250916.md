## 实验记录
遇到的问题是，在linux设置了nacc_flags的同时，这个时候这个进程还没有初始化agent部分，但是do_irq等函数已经被拿去使用了，这是不对的

因此，我们对于acall原语和aret应该还要做一些设置，这个地方jalr a1似乎没有成功地跳转回来，这非常奇怪，需要逐步跟踪一下，搞清楚为什么这件事情会发生
```C
SYM_FUNC_START(call_on_irq_stack)
	/* Create a frame record to save ra and s0 (fp) */
	addi	sp, sp, -STACKFRAME_SIZE_ON_STACK
	REG_S	ra, STACKFRAME_RA(sp)
	REG_S	s0, STACKFRAME_FP(sp)
	addi	s0, sp, STACKFRAME_SIZE_ON_STACK

	/* Switch to the per-CPU shadow call stack */
	scs_save_current
	scs_load_irq_stack t0

	/* Switch to the per-CPU IRQ stack and call the handler */
	load_per_cpu t0, irq_stack_ptr, t1
	li	t1, IRQ_STACK_SIZE
	add	sp, t0, t1
	jalr	a1

	/* Switch back to the thread shadow call stack */
	scs_load_current

	/* Switch back to the thread stack and restore ra and s0 */
	addi	sp, s0, -STACKFRAME_SIZE_ON_STACK
	REG_L	ra, STACKFRAME_RA(sp)
	REG_L	s0, STACKFRAME_FP(sp)
	addi	sp, sp, STACKFRAME_SIZE_ON_STACK

	ret
SYM_FUNC_END(call_on_irq_stack)
```

问题似乎在这里，运行到函数invoke_softirq的时候卡住了，让人觉得很诡异
```
invoke_softirq

while ((softirq_bit = ffs(pending)))
```
似乎卡在了这里，搞清楚一下是为什么，可能涉及了之前我没注意到的东西