## 实验记录
思考了一下之后，感觉这个问题其实本质上就是区分linux普通进程和agent进程的问题

只不过我们现在对于agent进程遇到的异常做了更加精细的区分
- agent进程中，来自于linux部分的异常依旧交给linux来处理，不通过aret指令返回到agent
- agent继承中，来自于agnet这个user app本身的进程交给agent先直接处理着

static RISCVException write_satp(CPURISCVState *env, int csrno,
                                 target_ulong val)
{
    if (!riscv_cpu_cfg(env)->mmu) {
        return RISCV_EXCP_NONE;
    }

    if (get_field(env->nacc_state, NACC_STATE_STATE_MASK) == NACC_STATE_LINUX) {
        return RISCV_EXCP_ILLEGAL_INST;
    }

    env->satp = legalize_xatp(env, env->satp, val);
    return RISCV_EXCP_NONE;
}

好家伙，原来是自己给自己挖的坑