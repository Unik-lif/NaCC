## 实验记录
更改了sm.c中sm_init_agent_verify接口，看起来原本用来存储satp和cid的数据结构没有什么大问题，至少现在是能work的
```shell
[SBI] Thread has been Switched!
[SBI] Detected new PGD: 1228dc will act as the Nacc Process with 820a6f81c0 as cid
[SBI] GO BACK.
[  250.576984] [Linux]: Back to do_irq in kernel. With regs: ffffffc600003cd0
env->mstatus: a000001a0
env->mstatus: a000001a0
[  250.593168] [Linux]: Back to do_irq in kernel. With regs: ffffffc600003cd0
env->mstatus: a000001a0
env->mstatus: a000001a0
[  250.594945] [Linux]: Back to do_irq in kernel. With regs: ffffffc600003bf0
env->mstatus: a000001a0
env->mstatus: a000001a0
[  250.596544] [Linux]: Back to do_irq in kernel. With regs: ffffffc60075b8f0
env->mstatus: a000000a0
[Qemu] Agent will jump to twin_entry!
[Agent]: usertrap
```
去掉我们在runc这边添加的系统调用位置，usertrap这一行就不再出现了，说明到此为止我们的实现是能够运行的

usertrap与时钟中断等的竞争
- 似乎是没有竞争的
- 系统调用发生后，会原子性地立刻切换到S mode，跑到S mode之后，时钟中断将会走另一条通路，不会干扰usertrap中对于trampoline寄存器的使用
- 系统调用发生前，时钟中断会走trampoline寄存器，并在agent和linux之间进行切换
- 因此应该是无需额外添加新寄存器用来区分

把这个加上了，看看效果，能不能成功正常地处理我们系统调用等异常

几个问题
- 会有一些用户访问出现的page fault，这些页的缺失并没有那么容易去做handle，也许直接做转发是不行的，因为连linux操作系统也没法做
- - 其实也不是不行，我们可以把先前的页表搬运代码给它注释掉
- sscratch的值有点奇怪，让其看起来像是由kernel触发的异常类型，这说明先前首次退出时的sscratch值并没有得到一个比较好的设置
- 和do_irq当时不同，似乎仍缺乏一个比较好的上下文存储方式，得继续尝试撰写代码
- 就sstatus的值上，似乎在__ret_from_exception位置并不是我们想要的值，这一点也很奇怪


```shell
[SBI] sm_init_agent_verify called with prev_pgd: 0, next_pgd: 10af85
[SBI] Thread has been Switched!
[SBI] Detected new PGD: 10af85 will act as the Nacc Process with 8b3d3bd0d6 as cid
[SBI] GO BACK.
[QEMU] addr: 180000154 Invalid Component has accessed the agent region!
[QEMU] Can't access physical address.
[  783.361956] Unable to handle kernel access to user memory without uaccess routines at virtual address 0000003f04000154
[  783.365652] Oops [#1]
[  783.366304] Modules linked in: veth xt_conntrack xt_MASQUERADE br_netfilter bridge stp llc nft_chain_nat nf_nat nf_conntrack xt_addrtype nft_compat xfrm_user xfrm_algo overlay 8021q drm drm_panel_orientation_quirks configfs backlight ip_tables x_tables
[  783.370878] CPU: 0 UID: 0 PID: 766 Comm: runc:[2:INIT] Not tainted 6.12.0-00005-g574fc0db19e3-dirty #1
[  783.371694] Hardware name: riscv-virtio,qemu (DT)
[  783.372276] epc : 0x3f04000154
[  783.373331]  ra : 0x3f04000154
[  783.373629] epc : 0000003f04000154 ra : 0000003f04000154 sp : ffffffc600723c10
[  783.374102]  gp : ffffffff81718d70 tp : ffffffd68859e600 t0 : 0000000000000001
[  783.374575]  t1 : 0000000000000001 t2 : 0000000000bea688 s0 : 0000003fc2f00720
[  783.375507]  s1 : 0000000200004020 a0 : 0000000000000000 a1 : ffffffc600723c10
[  783.376011]  a2 : 0000000000000000 a3 : 0000000000001000 a4 : 0000000000000000
[  783.376484]  a5 : 0000000000000000 a6 : 0000000000000001 a7 : 0000000000000001
[  783.376979]  s2 : 0000002abb7a8e2c s3 : 0000000000000000 s4 : 0000000000000008
```
这边的问题似乎是我们想让user app利用一个系统调用进行打印，但是在执行的过程中出现了新的页面异常

还有很多的问题需要解决
- 如何正确地处理page demanding情况
- 调度时更多的细节，我们观测到这个异常被linux所捕获，但这源自用户进程的一些异常，并不应该被linux捕获到，虽然上下文是切换过来了，但内核态想要进入user这边，应该不可避免还需要进行sret或者iret，我们需要保证这一部分的代码是正确的

在这个地方：ret_from_exception是调度之后，成功能够切换回user app的一个重要的途径：
```C
#ifdef CONFIG_RISCV_M_MODE
	mret
#else
	sret
#endif
SYM_CODE_END(ret_from_exception)
```
这个地方肯定是需要进行改造的，需要区分开来当前进程的类型，我们可能需要立足tp的值，利用一个函数宏来判断nacc状态中是否有值，从而让

此外，其他的handler函数的末尾也自然需要加上对于当前进程状态的一个基础判断，这个仿照我们对于linux do_irq函数的修改，从而确认linux是否需要通过aret返回到合适位置

未来可能会出现多个机密容器进程彼此之间互相调度的情况，很有可能一个trampoline寄存器并不能满足所需，未来大概率是需要在task_struct中添加新的trampoline项，用来存储之后跳转到agent的位置