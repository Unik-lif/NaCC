## 实验记录
发现了实验上的一些bug，即在do_trap_ecall_u这个位置的出口位置，没有正确选择参数来退出，

已经修正，并且完善了昨天的构想，去做一个测试系统调用来查看效果

不知道为什么在0x8b系统调用触发的时候出现了诡异的现象：

```
(gdb) p/x *(struct pt_regs *) regs
$4 = {epc = 0xffffffff80069d56, ra = 0xffffffff80a32e72, sp = 0xffffffc60077b350,
  gp = 0xffffffff81718d70, tp = 0xffffffd688c30cc0, t0 = 0x2, t1 = 0x0, t2 = 0xffffffc60077b3f0,
  s0 = 0xffffffc60077b370, s1 = 0xffffffd73fff7d40, a0 = 0x0, a1 = 0x1bffe800400, a2 = 0x80000,
  a3 = 0xffffffc600000000, a4 = 0x100000000, a5 = 0x2, a6 = 0xffffffd6a479db00,
  a7 = 0xffffffd6a479db68, s2 = 0xffffffd73ffe8fa8, s3 = 0x3f751f5000, s4 = 0xffffffc60077b3e0,
  s5 = 0xffffffd685bd4000, s6 = 0xffffffc60077b468, s7 = 0x0, s8 = 0x0, s9 = 0x0,
  s10 = 0xffffffc60077b4fc, s11 = 0x0, t3 = 0x1, t4 = 0xffffffd6a479db0c, t5 = 0x3f6d7bf000,
  t6 = 0x3f751f5fff, status = 0x200000120, badaddr = 0x4, cause = 0xd, orig_a0 = 0x0}
(gdb) bt
#0  die_kernel_fault (msg=0xffffffff811ff9b0 "NULL pointer dereference", addr=4,
    regs=0xffffffc60077b230) at /home/link/Desktop/NaCC/linux/arch/riscv/mm/fault.c:28
#1  0xffffffff8000c76c in no_context (regs=regs@entry=0xffffffc60077b230, addr=addr@entry=4)
    at /home/link/Desktop/NaCC/linux/arch/riscv/mm/fault.c:59
#2  0xffffffff8000cb3a in no_context (regs=0xffffffc60077b230, addr=4)
    at /home/link/Desktop/NaCC/linux/include/linux/sched/signal.h:424
#3  handle_page_fault (regs=regs@entry=0xffffffc60077b230)
    at /home/link/Desktop/NaCC/linux/arch/riscv/mm/fault.c:267
#4  0xffffffff80a29102 in do_page_fault (regs=0xffffffc60077b230)
    at /home/link/Desktop/NaCC/linux/arch/riscv/kernel/traps.c:373
#5  0xffffffff80a3364e in handle_exception ()
    at /home/link/Desktop/NaCC/linux/arch/riscv/kernel/entry.S:197
Backtrace stopped: frame did not save the PC
```
可能还是得想办法排查一下，从这里看出来，是某个系统调用在运行的时候，触发了do_page_fault，但是正常情况下do_page_fault是不会被触发的吧.....

可能得想办法深入到具体的这个系统调用所对应的位置

看起来对应的这个addr本来也就是没有内存的，总感觉是我们的这个系统调用没有好好处理好，没有好好存放好参数，从而导致了这个结果，我们可能得仔细地查看一下