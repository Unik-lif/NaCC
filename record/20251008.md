## 实验记录
稍微有了一些眉目，原因主要是在系统调用结束后，发现有信号出现，为此走向了do_coredump分支

由于我们机密容器的内存放到了机密区域，操作系统没有办法对其页表页等项进行访问，进而在处理页的时候出错了

可是这里有一个很关键的位置，还需要澄清
- 我们出现的异常是尝试处理信号量时，在对用户态程序做coredump的时候发生的
- 做coredump肯定是会出错的，因为操作系统没有办法对机密容器进程进行coredump
- 关键的问题应该是，谁触发了这个恶意的信号？是谁的访问导致的？

我需要首先找到是谁导致了这个SIGSEGV异常的来源，我觉得有可能是用户态程序触发的问题，原因是
```
root@Ubuntu-riscv64:~# docker run --security-opt seccomp=unconfined hello-world
[runc]: Start here: 38ddc3e14f6a82f33f9fe3940084cffdfdd2cbac14a507e27f84704664b2cd7b
[runc]: The container ID: 38ddc3e14f
[runc] allocated a contiguous 512 MB virtual address region for agnet start from 0x3f00000000
SIGSEGV: segmentation violation
PC=0x3f87a985b8 m=0 sigcode=128 addr=0x0                                                                                                                                                                                                                                                                                                                                                                                          goroutine 1 gp=0x3f3c0001c0 m=0 mp=0x2ada1e1d60 [syscall, locked to thread]:                                                                                                                                     root@Ubuntu-riscv64:~# reboot
```
我有时候能够看到这边的报错，这个报错应该是GO runtime报错的，看起来好像真的一开始的错误源自于用户态？