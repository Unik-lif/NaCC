## 实验记录
看起来主要还是这个问题
```
[  275.670211] [Linux]: 'do_page_fault' t3 (x28): 0xffffffff8172fb1f                                                                                  [  275.670769] [Linux]: 'do_page_fault' t4 (x29): 0xffffffff8172fb1f                                                                                  [  275.671331] [Linux]: 'do_page_fault' t5 (x30): 0xffffffc600e0bb08                                                                                  [  275.671905] [Linux]: 'do_page_fault' t6 (x31): 0x40000                                                                                             [  275.672421] [Linux]: 'do_page_fault' status: 0x200040120                                                                                           [  275.672953] [Linux]: 'do_page_fault' badaddr: 0x386332656531320b                                                                                   [  275.673520] [Linux]: 'do_page_fault' cause: 0xd                                                                                                    [  275.673972] [Linux]: 'do_page_fault' orig_a0: 0xffffffff80004798
[  275.674558] [Linux]: 'handle_page_fault' pt_regs details:
[  275.675079] [Linux]: 'handle_page_fault' regs: 0xffffffc600e0b9d0
```
这里有一个看上去非常诡异的问题，他是在访问badaddr，也就是一个非常奇怪的虚拟地址的时候出的错误

尝试跟踪了一下，确实是这个函数处理的过程中（在handle_page_fault）的时候，在一个叫做
```C
static inline void
bad_area_nosemaphore(struct pt_regs *regs, int code, unsigned long addr)
{
	/*
	 * Something tried to access memory that isn't in our memory map.
	 * Fix it, but check if it's kernel or user first.
	 */
	/* User mode accesses just cause a SIGSEGV */
	if (user_mode(regs)) {
		do_trap(regs, SIGSEGV, code, addr);
		return;
	}

	no_context(regs, addr);
}
```
的位置，发送了SIGSEGV信号，因此本质上我们的SIGSEGV信号是OS在访问某个关键区域的时候，出现的异常信息，而不是机密容器user app在访问的时候出现的信号量值

我们搞清楚了这个SIGSEGV信号产生的原因之后

出错位置似乎还是在：fallback_scalar_usercopy这个位置上，我们可以确认大概是这个的访问，才在之后导致了page fault，最后才招致了后续的SIGSEGV信号

再阅读源码确认一下