## 实验记录
主要解读handle_page_fault函数

看起来这个函数中一共有两个链路
- 快速查找链路: lock_vma_under_rcu
    - 似乎还使用了Maple Tree来提高性能
- 慢速查找链路: lock_mm_and_find_vma
    - 最经典的mm下红黑树结构来查找vma
- 在快速查找链路失效的情况下，重新开始查找，进入慢速查找链路

rcu机制，主要是为了同步，让读者无损，写者同步，本质上是一个为了高性能的同步机制
- read
- copy
- update

快速查找似乎使用rcu锁来实现同步，相关论文需要好好阅读清楚

- handle_mm_fault
    - __handle_mm_fault
        - p4d_alloc: 判断一下p4d是否存在
            - __p4d_alloc
                - get_zeroed_page: 在这一步生成了metadata，struct page*的数据
        - pud_alloc
        - pmd_alloc

太复杂了，感觉伪造可能并不是好的点子

那么也许一个更好的解法是构造映射表
```
如果我没有理解错误的话，也许你的方案A我真的可以考虑一下

这个听起来应该像是，用机密内存替换页表页后，原有的页表页所对应的metadata一定是合法的，只不过现在得用一种方式，让OS在进行PTW的时候，能够找到页表结构位置一一对应的原页表页，从而能够正确地操作他们的页表页数据

至于未来新增加的页表页，它自然就是有正确的metadata数据的

我的理解是对的吗

完全对 ✅，而且你已经准确地抓住了方案 A 的核心逻辑与它成立的根本原因。
我帮你把这句话展开、精炼成一个你在实现和写论文时都能直接引用的“核心原则式理解”，这样后续你不会被细节绕进去。

---

## 🧠 核心思想（你已经讲对的部分）

> “机密内存替换页表页后，原有页表页的 `struct page` 等 metadata 本身仍然是内核创建的、合法的；我们只需确保内核在执行自己的页表操作时，能通过原来的 metadata 定位到 **‘与之逻辑上对应的实际页表数据（现在在机密内存中）’**。”

换句话说：

* **原始页表页的 metadata 不应该被破坏或替换。**
  它仍然代表那个“逻辑上的页表页”，只是现在这页的数据搬到了 secure memory。

* **Host OS 看到的页表页 metadata 依旧是“合法页”，** 因此所有依赖 `struct page` 的内核路径（`handle_mm_fault`, `do_page_fault`, `free_pgtables`, `zap_pte_range` 等）都可以照常工作。

* **区别只在于：当 OS 或 CPU 真的要“访问页表内容”时（读写页表数据），**
  我们需要一个 **映射或代理层**（由 Secure Monitor 或轻量中间层完成），
  将这类访问重定向到机密内存中真实存在的页表页。

---

## 🧩 这样做的结果

1. **页表元数据路径保持原状**
   内核的 `mm_struct`、`vma`、`pgd/p4d/pmd/pte` 分配与销毁逻辑都不需要改。
   你只需要在：

   * 页表页分配（`p4d_alloc/pmd_alloc/pte_alloc`）
   * 页表页释放（`free_pgd_range/free_pte_range`）
     这些地方插一个小钩子，把「物理帧迁移到 secure memory + 记录映射」。

2. **PTW 路径重定向**
   在 CPU 做页表遍历（PTW）时，Host OS 看到的页表页物理地址仍是合法页，
   但我们在实际访问这些物理页（例如 `__get_free_page` 或 `memcpy_from_pte` ）时，
   将它替换为 secure memory 中的 “真实页表页”。

   对于 CPU 的硬件访问（非软件路径），Secure Monitor 可通过 PMP 机制直接让 PTW 访问机密页表区域；Host OS 则永远访问不到。

3. **未来新增页表页不会有问题**
   新分配的页表页走正常流程，Linux 会自动创建对应的 `struct page`。
   你只需要在“保护（搬运）”那一刻记录好它的新映射。

---

## 📘 可以把你的理解总结成一句原则（用于论文或实现文档）

> **“我们保持原有页表页的内核元数据不变，只替换其底层物理承载。机密页表页的真实内容存放在受保护的机密内存中，而 Host OS 持有的 `struct page` 仅作为逻辑句柄。由 Secure Monitor 负责在逻辑与物理之间维护一一对应关系，并在页表访问时进行安全重定向。”**

---

## ✅ 所以你的理解总结如下：

| 方面                     | 是否需要改动      | 说明              |
| ---------------------- | ----------- | --------------- |
| `struct page` 及内核内存元数据 | ❌ 不需要伪造     | 使用原生合法 metadata |
| 原页表页物理帧                | ✅ 被搬运至机密内存  | SM 管理其安全性       |
| 内核页表操作逻辑               | ❌ 不改        | OS 正常走原逻辑       |
| 页表内容访问路径               | ⚙️ 需要拦截/重定向 | 通过 SM 或 PMP 代理  |
| 新增页表页                  | ✅ 正常分配      | 元数据自然正确         |

---

你现在的表述（“未来新增加的页表页，它自然就是有正确的metadata数据”）完全成立；
只要在“机密搬运”的过程中把旧页表页的 metadata 保留下来并建立映射关系，这套体系就自洽了。

---

如果你想，我可以在下一步帮你画出这套「metadata–secure page 映射体系」的逻辑结构图（包括在何处做 hook、哪些结构要同步），方便后续写设计文档或实现时对齐。是否需要我帮你画一份？

```