## 实验记录
我的时间真的好少...我得努力推进项目！

```
root@Ubuntu-riscv64:~/riscv-docker/runc# cat /proc/meminfo                                     
MemTotal:        3999404 kB
MemFree:         3223116 kB 

root@Ubuntu-riscv64:~# cat /proc/meminfo
MemTotal:        4000428 kB
MemFree:         3597576 kB

```
看起来分配的这一个用于记录mappings的1MB已经得到了妥善的使用

当linux尝试寻找struct page*这个数据结构的时候，首先linux会拿到new_pfn，并以此去查阅
- 输入new_pfn，确认其所对应的范围是否是在特殊区间
- 如果是，则直接通过mappings找到对应的old_pfn
- 最终通过索引old_pfn找到正确的struct page*数据结构体

新的页表页一共有0x10000这么多个，为了方便，我们使用old_pfn和new_pfn一共有16个字节，这样正好是一个MB

不对，我们只要存放old_pfn就行了，new_pfn直接通过索引来找到就行了

两个优化选项后续我们需要做
- bitmap的批处理优化
- mappings区域的批处理优化

似乎是有一些空间上地浪费，但是这边涉及了一些编程上和参数的麻烦事情，我尽量避免之，就暂时还是用1MB吧

实际上应该用的是256 KB，这应该就是很小的空间了，不过为了方便我们还是用一个MB

那么这边做标记就已经实现了，下面是在linux这边把相关的宏写进去，需要注意的是用虚拟地址

那么应该是锁定到，本身去找这些pfn被使用的地方，在那个地方直接写宏定义就行

__page_val_to_pfn函数需要进行修改

```C
/* memmap is virtually contiguous.  */
#define __pfn_to_page(pfn)	(vmemmap + (pfn))
#define __page_to_pfn(page)	(unsigned long)((page) - vmemmap)
```

这边的逻辑确定好后，我们就休息
- pfn先去看看范围，如果在某个范围，就做修正（很简单）
- 后面的，也很简单

说明我们搞mappings区域是一个好的实践，可以利用位运算来做