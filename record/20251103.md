## 实验记录
我们落实一下下面的这两个函数
```C
/* memmap is virtually contiguous.  */
#define __pfn_to_page(pfn)	(vmemmap + (pfn))
#define __page_to_pfn(page)	(unsigned long)((page) - vmemmap)
```

函数似乎是写好了，但是似乎没有找对到底是哪一个分支，还需要再看看

确定了，但是修改了宏以后，性能变得实在很差，甚至没法正常启动，我觉得可能需要下陷到具体的母函数那边，为机密进程专门开一个pfn_to_page之类的？

ok，把限定范围搞小一点，似乎这个性能问题暂时解决了，具体之后还会不会报错，这还是一个很难的问题，需要继续花时间看

现在是又有新的报错，果然一点都不容易，就算我们得到了正确的映射对应关系，我们先用单核来看看怎么回事，多核的话qemu似乎直接崩了
```
[  384.267634] status: 0000000200000120 badaddr: ffffffd73fffd760 cause: 0000000000000007
[  384.267923] [<ffffffff8018f3ae>] unmap_page_range+0x584/0xac8
[  384.268230] [<ffffffff8018f92a>] unmap_single_vma.isra.0+0x38/0x5e
[  384.268271] [<ffffffff8018f9d0>] unmap_vmas+0x80/0x176
[  384.268307] [<ffffffff8019a97a>] exit_mmap+0xb2/0x25a
[  384.268344] [<ffffffff80010a62>] mmput+0x52/0xf2
[  384.268388] [<ffffffff801f9e3a>] begin_new_exec+0x3a6/0xa1a
[  384.268443] [<ffffffff8024b212>] load_elf_binary+0x278/0x12ae
[  384.268483] [<ffffffff801f8256>] bprm_execve+0x1e4/0x470
[  384.268519] [<ffffffff801f9828>] do_execveat_common.isra.0+0x138/0x166
[  384.268557] [<ffffffff801fa4e4>] __riscv_sys_execve+0x36/0x3e
[  384.268594] [<ffffffff80a294a8>] do_trap_ecall_u+0x176/0x254
[  384.268642] [<ffffffff80a33e3e>] _new_vmalloc_restore_context_a0+0xc2/0xce
```

尝试跟踪一下

跑崩的位置
```
0xffffffd73fffd9d8

ffffffd700000000 0000000180000000 0000000040000000 rw--gad
```
那这本质上就是去访问了我们agent这边的物理地址，不过为什么是7号异常呢？

我们需要搞清楚的两点
- 为什么是7号异常，虽然这个异常能够由我们opensbi来进行处理，但是为什么以预留页方式的页地址使用，被定义为了七号异常。这个本质上就是store的异常，我们read的时候，显然是没有出问题
- 到底是在哪个环节对这个页进行了处理？这好奇怪哦！而且根据GDB来跟，似乎并不是我们目前观测到的spin_lock位置，具体是在哪里呢？

搞清楚是这个现象后反而觉得似乎可以做下去了

下班！今天工作了很久，达到自己的要求了！