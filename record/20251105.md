## 实验记录
继续仔细分析这一部分代码
```C
static __always_inline void zap_present_folio_ptes(struct mmu_gather *tlb,
		struct vm_area_struct *vma, struct folio *folio,
		struct page *page, pte_t *pte, pte_t ptent, unsigned int nr,
		unsigned long addr, struct zap_details *details, int *rss,
		bool *force_flush, bool *force_break)
{
	struct mm_struct *mm = tlb->mm;
	bool delay_rmap = false;

    // 如果页面并非匿名内存，即来自于文件内存
	if (!folio_test_anon(folio)) {
        // 那么还要把ptes对应的区域打上标记，然后再做清空
		ptent = get_and_clear_full_ptes(mm, addr, pte, nr, tlb->fullmm);
		if (pte_dirty(ptent)) {
            // 如果对应的是脏页，那么还要把这个信息回收并且记录到folio之中
			folio_mark_dirty(folio);
			if (tlb_delay_rmap(tlb)) {
				delay_rmap = true;
				*force_flush = true;
			}
		}
		if (pte_young(ptent) && likely(vma_has_recency(vma)))
			folio_mark_accessed(folio);
		rss[mm_counter(folio)] -= nr;
	} else {
		/* We don't need up-to-date accessed/dirty bits. */
		clear_full_ptes(mm, addr, pte, nr, tlb->fullmm);
		rss[MM_ANONPAGES] -= nr;
	}
	/* Checking a single PTE in a batch is sufficient. */
	arch_check_zapped_pte(vma, ptent);
	tlb_remove_tlb_entries(tlb, pte, nr, addr);
	if (unlikely(userfaultfd_pte_wp(vma, ptent)))
		zap_install_uffd_wp_if_needed(vma, addr, pte, nr, details,
					      ptent);

	if (!delay_rmap) {
		folio_remove_rmap_ptes(folio, page, nr, vma);

		if (unlikely(folio_mapcount(folio) < 0))
			print_bad_pte(vma, addr, ptent, page);
	}
	if (unlikely(__tlb_remove_folio_pages(tlb, page, nr, delay_rmap))) {
		*force_flush = true;
		*force_break = true;
	}
}
```
看起来除了涉及clear_ptes的函数，都没有真正去篡改我们的机密内存页表页
```C
static inline pte_t get_and_clear_full_ptes(struct mm_struct *mm,
		unsigned long addr, pte_t *ptep, unsigned int nr, int full)
{
	pte_t pte, tmp_pte;
    // 处理第一个PTE
	pte = ptep_get_and_clear_full(mm, addr, ptep, full);
	while (--nr) {
		ptep++;
		addr += PAGE_SIZE;
        // 似乎是用pte来尝试做累加，如何下面的tmp_pte其中任何一个是脏的或者被访问过，那么这一串的pte都将会被视作同一种类型
		tmp_pte = ptep_get_and_clear_full(mm, addr, ptep, full);
		if (pte_dirty(tmp_pte))
			pte = pte_mkdirty(pte);
		if (pte_young(tmp_pte))
			pte = pte_mkyoung(pte);
	}
	return pte;
}
```
似乎是找到了最关键的位置，如下所示
```C
static inline pte_t ptep_get_and_clear(struct mm_struct *mm,
				       unsigned long address, pte_t *ptep)
{
	pte_t pte = __pte(atomic_long_xchg((atomic_long_t *)ptep, 0));

	page_table_check_pte_clear(mm, pte);

	return pte;
}
```
这个地方是以原子操作尝试清空PTE的，那么自然会导致问题。


好的，我们已经搞清楚了为什么会出现之前的那个问题，现在我们需要查看QEMU对于这个错误的定义是否符合我们的期望
- 不知道到底是PMP拒绝掉它，亦或是其他的什么原因，我们先尝试把PMP区域给他打开
	- 确实是PMP拒绝掉它导致的异常类型


还有几个问题
- 如何让SBI能够处理这个异常问题
- 这个修改的粒度很有点小，如果一直向下请求去做修改，似乎性能会很不好
	- 因此我们得使用一个类似于page fault这样的机制，在捕获到这个页的位置之后，尽量减小后续的这个开销（比如跳过之后出错的验证）
