## 实验记录
尝试修改__pte_map函数，未果，有一些困惑，需要仔细地考虑清楚
```C
pte_t *current_pte = pte_offset_kernel(pmd, address);
```
内核此处先根据pmd，找到pmd地址指向的页表页，然后利用address来索引得到pmd对应页表页中，下一级PTE所对应的虚拟地址
```
           PMD
pmd_t*--> +-----+           PTE
          | ptr |-------> +-----+
          | ptr |-        | ptr |-------> PAGE
          | ptr | \       | ptr |
          | ptr |  \        ...
          | ... |   \
          | ptr |    \         PTE
          +-----+     +----> +-----+
                             | ptr |-------> PAGE
                             | ptr |

```
pmd所对应的指针存放在L0页表页中，它所对应的物理地址是在Linux可以访问的区域（在添加我们的限制之前）
```
[  186.268473] [Linux]: nacc_map pmd: pfn=0x1bfffd, actual_pfn=0x107f59
[  186.269048] desc: ffffffc5021fd640 pmd: ffffffc60070b930 *pmd pfn: 1bfffd *pmd: 6ffff401
```
但是对于*pmd这个值的解析则相对复杂一些，`__page_val_to_pfn(pmd_val(*pmd))`对应的是1bfffd，`pmd_val(*pmd)`对应的是6ffff401

这边的*pmd对应的数据类型是pmd_t，而不是PMD中第一个ptr这个指针，pmd指向的就是PMD页表页本身，这一点非常容易搞混

因此，我们这边读取得到的pfn，其实就是PMD页表页所对应的pfn，因此这边的替换应该是正确的

对于PMD页表页中元素的获取方式，linux采用下面的方式来做
```C
__pte_map(&pmdval, addr)

pte_t *current_pte = pte_offset_kernel(pmd, address);

static inline pte_t *pte_offset_kernel(pmd_t *pmd, unsigned long address)
{
	return (pte_t *)pmd_page_vaddr(*pmd) + pte_index(address);
}

static inline unsigned long pmd_page_vaddr(pmd_t pmd)
{
	return (unsigned long)pfn_to_virt(__page_val_to_pfn(pmd_val(pmd)));
}

#define pfn_to_virt(pfn)	(__va(pfn_to_phys(pfn)))

#define __va(x)		((void *)__pa_to_va_nodebug((phys_addr_t)(x)))

#define __pa_to_va_nodebug(x)		linear_mapping_pa_to_va(x)

#define linear_mapping_pa_to_va(x)	((void *)((unsigned long)(x) + kernel_map.va_pa_offset))
```
这边感觉最关键的是采用linear_mapping_pa_to_va的方式来进行地址映射，听起来很新奇
- 在启动的时候建立了一个直接映射，可以通过简单的算数进行转化

好像搞错了？似乎？

我们观察到下面的现象：
```
[  156.005526] unmap_page_range: Before zap_p4d_range
[  156.005947] pgd pfn: 1bfffe addr: 2ab779c000
[  156.006291] zap_p4d_range: Before zap_pud_range
[  156.006627] pgd pfn: 1bfffe p4d pfn: 1bfffe
[  156.006946] zap_pud_range: Before zap_pmd_range
[  156.007264] p4d pfn: 1bfffe pud pfn: 1bfffe
[  156.007585] zap_pmd_range: Before zap_pte_range
[  156.007919] pud pfn: 1bfffe pmd pfn: 1bfffd
[  156.010619] zap_pte_range:
[  156.010844] pmd pfn: 1bfffd pte pfn: 113f78

```
看起来我是搞错了，之前以为三级页表的形态就是L0页表，L1页表，L2页表就好了，但是实际上应该还有一层，应该像这个一样最后一级的PTE页表我并没有搬运，这个很致命，让我们的防护其实并不彻底，难怪出了一些奇怪的问题

？感觉opensbi视角的页表和linux视角的页表并不一致？我再确认一下？

好像其实是一样的，我们的页表也没有搬运错，但是linux这边对于这些页的描述似乎和我们直觉上不大一样

总结一句话，linux视角下的这些名词，必须用数组来理解，否则真的会把人搞混！！！我受不了了！