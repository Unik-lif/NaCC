## 实验记录
```
[  269.911360] CPU: 0 UID: 0 PID: 745 Comm: runc:[2:INIT] Not tainted 6.12.0-00008-gded411cd7b9f-dirty #1
[  269.911527] Hardware name: riscv-virtio,qemu (DT)
[  269.911830] epc : free_pgd_range+0x528/0xa42
[  269.913354]  ra : free_pgd_range+0x12e/0xa42
[  269.913452] epc : ffffffff8018de86 ra : ffffffff8018da8c sp : ffffffc60065b980
[  269.913510]  gp : ffffffff81718d70 tp : ffffffd685223fc0 t0 : 0000000000000002
[  269.913561]  t1 : 0000000000000003 t2 : 0000000000000002 s0 : ffffffc60065ba70
[  269.913611]  s1 : ffffffd73fffea68 a0 : 0000000100000000 a1 : 0000000080000000
[  269.913660]  a2 : ffffffc600000000 a3 : 0000002ae9a00000 a4 : 0000000000000001
[  269.913716]  a5 : 00000fffffffffff a6 : 0000002aea4c8000 a7 : ffffffd684a63df0
[  269.913768]  s2 : ffffffc60065bb88 s3 : 0000002aea4c8000 s4 : 0000002aea4c7fff
[  269.913818]  s5 : ffffffffffe00000 s6 : ffffffffffffffff s7 : 0000000000200000
[  269.913867]  s8 : 0000002ae9c00000 s9 : ffffffc60065bb88 s10: 00000000001bfffd
[  269.913917]  s11: ffffffff812ca558 t3 : ffffffffffffffb8 t4 : ffffffd688578688
[  269.913963]  t5 : ffffffd6885786c0 t6 : 0000003f34020fff
[  269.914009] status: 0000000200000120 badaddr: ffffffd73fffea68 cause: 0000000000000007
[  269.914338] [<ffffffff8018de86>] free_pgd_range+0x528/0xa42
[  269.914657] [<ffffffff8018e44e>] free_pgtables+0xae/0x238
[  269.914701] [<ffffffff8019ac50>] exit_mmap+0x11c/0x25a
[  269.914742] [<ffffffff80010a42>] mmput+0x52/0xf2
[  269.914790] [<ffffffff801fa166>] begin_new_exec+0x3a6/0xa1a
[  269.914839] [<ffffffff8024b53e>] load_elf_binary+0x278/0x12ae
[  269.914886] [<ffffffff801f8582>] bprm_execve+0x1e4/0x470
[  269.914927] [<ffffffff801f9b54>] do_execveat_common.isra.0+0x138/0x166
[  269.914970] [<ffffffff801fa810>] __riscv_sys_execve+0x36/0x3e
[  269.915012] [<ffffffff80a29820>] do_trap_ecall_u+0x176/0x254
[  269.915061] [<ffffffff80a3406e>] _new_vmalloc_restore_context_a0+0xc2/0xce
```


解决了一小部分了！现在推进到了这边的异常位置

当前的进度总结
- 完成了unmap_exit部分的正常化
    - 在该部分linux会在给末级页表页上锁之后，对末级页面进行清空
    - 我们没有操作真的末级页表页，而是去找到被替换前的末级页表页，对其相关的页面进行清空
    - 这里留了一个坑，有可能末级页表页，是在之后通过page fault操作后加上的，先前可能没有存在
        - 后续也许需要在完善了page fault处理的流程之后，思考如何对其进行销毁，总体来说应该是可以通过pfn和mappings确认其是否是后分配的（而不是被替换环节拿去做分配的）
        - 出现这种情况，则在给PMD加锁的那一刻确认这是后分配的，然后再跳过后面的检查流程（不需要再按照正常的流程去对其做处理，因为并没有旧页表页与之对应上）
- free_pgtables阶段
    - 应该在这个阶段尝试对页表页进行回收（同步要求opensbi回收此处的页表页）


绘制了一些图片去解决，这边的思考量相当大，我需要更加谨慎地学习清楚