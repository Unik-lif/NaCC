## 实验记录
除了exit_unmap的环节会调用free_pgtables之外，其他的一些系统调用也有调用这个函数的可能性，而很致命的一点是他们也还是机密容器进程运行时可能会遇到的进程，当我们标注了某个进程是机密容器进程之后，也许并不是说这个进程的全程内存保护都做的很妥善？

别急，我们可以多加一些检查，毕竟可能有一些情况我们考虑不到

过了这个部分

现在我们尝试上四个核来跑跑看效果，上多核也没有问题，好的，那么这个部分我们可以暂时收手了，


我们现在尝试解决更早之前我们遇到的问题，恢复一下代码，把agent部分重新加载回来，同时检测其在多核环境下的稳定度

和先前相比我们的方案出现了一定的变动，想清楚先
- runc这边在进入exec之前，需要发给底下的opensbi，注册自身，同时linux这边要标记上它为机密容器进程
- 进入主进程的exec分支，OS发现其为机密容器进程，于是特殊处理之
    - 先由内核去寻找一块空缺出来的虚拟地址空间，处理方式和用户态mmap类似，没有太多区别，API注意一下就行，得到一个虚拟地址
    - 再搬运页表，把这个虚拟地址一并送进去
    
因此，当务之急是搞清楚linux是怎么跑exec这个系统调用的