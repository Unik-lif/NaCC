## 实验记录
对于代码进行了大改和重构，pay attention to some冗余位置

利用pgd和cid来进行构建container数据结构

有一个下面的这样的表，其中containers和pgd_hash_table
```C
/*
 * The 'nacc_process' can be identified with pgd (Page Global Directory).
 * With 'pgd', we can modify the page table of the 'nacc_process'.
 * pgd stores the physical page number (PPN) of the page table root.
 */
typedef struct nacc_process {
    unsigned long pgd;
} nacc_process_t;

/*
 * The 'nacc_container' is a container that can contain multiple 'nacc_process'.
 * Current we just support limited number of 'nacc_process' in a 'nacc_container'.
 */
typedef struct nacc_container {
    uintptr_t cid;
    uint32_t count;
    nacc_process_t processes[MAX_PROCESS];
} nacc_container_t;

/*
 * Hash table entry for PGD lookup.
 * To quickly find which container and process index a PGD belongs to, use the container_idx and process_idx.
 */
typedef struct pgd_hash_entry {
    unsigned long pgd;
    uintptr_t cid;                        /* Which container this PGD belongs to */
    int container_idx;                    /* Index in nacc_table.containers */
    int process_idx;                      /* Index in container.processes */
} pgd_hash_entry_t;

/*
 * The 'nacc_table' is a table that can contain multiple 'nacc_container'.
 * Current we just support limited number of 'nacc_container' in a 'nacc_table'.
 */
typedef struct nacc_table {
    nacc_container_t containers[MAX_CONTAINER];
    int count;
    
    /* PGD hash table for fast PGD->CID lookup */
    pgd_hash_entry_t pgd_hash_table[SATP_HASH_SIZE];
} nacc_table_t;
```
当一个新进程进来之后，系统会根据pgd来快速找到对应的cid情况
- 快速路径是直接根据PGD对应的hash值，找到对应的条目，从而确认cid和所归属的容器index，进程index位置，这两个index主要是便于锁定nacc_container_t containers中具体对应的是哪个单元，以此确认该进程具体是在哪个container名下
- 慢速路径则是通过container这边进行进程遍历来找到对应位置，container存放了更多的信息，包括这个container名下有多少个进程

重构逻辑
- 以opensbi作为最终解释权