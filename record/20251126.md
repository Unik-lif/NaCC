## 实验记录
似乎流程上有点问题，由于我们有一个为了schedule来做的器械，他会自动根据nacc_flag为1的新进程，发送信息给SBI来验证这个这个新进程是否是机密容器进程

这件事情是必要的，但是我们的启动流程发生了改变，因此需要对这个东西做了微调

一个机密容器进程启动的步骤应该是下面这样
- 它向monitor进行注册，把cid和进程号信息传送下去，但是此时不能设置current.thread->nacc_flag为1，还不能告知操作系统这个进程是机密容器进程，否则会影响调度
    - 我们不如在这个位置设置nacc_flag为2，表示正在准备当中
- 它和一般进程一样正常进行调度运行
- 运行到后头，runc这边触发了exec系统调用，控制流进入到linux这边
- linux负责布置好它的地址上下文信息，我们在start_thread的入口中进行机密容器分支的改动
    - 根据nacc_flag为2知道这个东西已经处于待注册的状态了
    - 此时再设置nacc_flag为1，我们还需要保证控制流是从exec系统调用这边飞走了，不能走后续do_trap_ecall_u的返回老路
    - 搬运PTP页表页，并让monitor进行Agent区域的映射工作
    - monitor跳转进入到agent中，agent做好初始化，利用从linux这边传递过来的linux上下文信息，直接跳转回user app程序

试试看！
```C
    /* 
     * [TODO]
     * - First allocate a contiguous virtual memory region to the process, for agent.
     * - Then transfer the PTP.
     */
     if(current->thread.nacc_flag == 2) {
        printk(KERN_ERR "[Linux]: start_thread is invoked for NACC process. \n");
        virt_agent = nacc_get_unmapped_area_aligned(NULL, 0, NACC_AGENT_MEM_SIZE, 0, 0, 0);
        printk(KERN_ERR "[Linux]: Found an unmapped region with virt_agent %lx\n", virt_agent);
    }
```

奇怪的部分
- 自己写的get_unmapped_area_aligned似乎并不能work
- NACC_invoke得到了裁剪，需要重新注意去修改相关的宏值

需要再仔细调试一下