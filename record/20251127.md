## 实验记录
```
[SBI] Linux mapped agent region [3f99cd9000, 3f99ce1000]
[SBI] want to jump to the agent region at va: 3f99cd9000 pa: 180000000
[QEMU] addr: 180005000 Invalid Component has accessed the agent region!
[QEMU] Can't access physical address.
```

看起来昨天遇到的问题已经无法复现出来了，具体是怎么做到的我不大清楚，可能是某处修改无意识地订正了这个问题

观测到一个现象，exec系统调用前后的satp是会发生变化的，这和我一开始所做的假设不大一样，我可能得好好思考怎么去修改这件事情

一些讨论
- 每次exec系统调用都会进行一次彻底的地址空间清空，包括修改pgd，所以就得重新进行一次Page Table的transfer
- 因此，在monitor这边存放pgd和cid的对应情况，也许并不是一个好的主意

可能的解决方法
- 如果我们尝试用pid来作为标识符，在打上标志之后，通过ecall来让monitor验证当前的进程是否是机密容器进程
- pid可能有点赤裸裸，也许也可以采用task_struct所对应的地址，但本质上并没有区别，我们假设这个地方攻击者就是可以拿到明文
- 可能存在的一些攻击情况
    - 如果有一个机密容器进程在传递的时候，其对应的正确pid被linux所篡改，则该机密容器进程对应的nacc_state寄存器将不会有正确的值，此类攻击为DOS
    - 如果有一个正常进程在被调度的时候，传递了机密容器进程的pid，是否有可能提权？
        - 关键是我们希望达成什么效果，它并不能因为传递了机密容器对应的pid，被写了nacc_state，从而实现了对于agent区域的访问，因为并没有给他注册上对应的agent区域地址空间
        - 在机密容器第一个进程注册的时候，需要提供cid，这个值并不能从OS这边拿到
    - 我们逆向思考这件事情，agent区域，即机密容器区域是在什么情况下才会被拿去使用（目前只考虑机密容器中的第一个进程）
        - 启动的时候已经通过注册，将自己成功注册上，进程类型为最初的进程，nacc_flag = 2表示即将成为真正的机密容器进程
        - 通过nacc_invoke，agent对应的地址空间被映射了
        - 条件：注册过，使得自己一开始nacc_flag = 2，之后通过nacc_invoke映射了agent对应的地址空间，修改nacc_flag = 1
        - 反面：
            - 一个普通进程可以让OS修改自己的nacc_flag为2，而不通过注册
                - 修改了nacc_flag为2后，并不能通过调度来做好提权
                - 一个普通进程尝试在nacc_flag为2的前提下，尝试利用nacc_invoke来提权
                    - 进入nacc_invoke执行流程函数之后，第一步就得去验证其是否被注册
            - 一个普通进程拿了一个机密容器进程的pid，使用别人机密容器被注册后的号
                - 它还可以随便改nacc_flag的值，那还是不行，这个攻击可以构造出来的
- 关键：被注册的机密容器进程需要有一个无法被linux所构造的标识符