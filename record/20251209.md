## 实验记录
尝试为nacc_flag新添加了一些状态类型，其他几个问题不大，调度上这边可能得想一想

目前我们利用NACC_PREPARE表示某个CID已经向Monitor进行注册了，这个用于注册的进程其实就是容器的第一个进程，它会在之后执行execve系统调用

暂时假设只有一个机密容器进程，即hello world的情况
- 如果先前的进程是机密容器进程，而之后的进程马上变成内核进程了
    - 需要清空nacc_state寄存器信息，否则会有安全隐患

我们本来设置了一个机密容器窗口，prev进程和next进程都是重要组成部分，都需要具体去看它们在调度的时候对应的值

注册之后马上就要通过一个nacc_invoke来进行agent的初始化，
- 准备状态和初始化完毕状态必须要分开，如果两个状态没有分开，之后的ecall就会尝试跳转到agent区域，而此时agent区域完全没有注册过
- 调度的时候会根据某个进程是否是机密容器进程，修改nacc_state寄存器的值，注册与否根据是否经历了准备状态即可判断
- 如果机密容器进程刚刚注册上，就被调度走了，等它重新被调度回来，被写上了nacc_state，但是里头默认此时是Linux状态，而很有可能程序正好之前运行在Agent状态，从而出现差异

并不会出现这个问题
- 控制流在agent和opensbi中时，linux无从调度它
- 控制流在用户态或者linux的时候，nacc_state都可以写成Linux状态，这里我们并没有做明显的区分

偶然发现了多核下的一个问题，但是并不是每次都能成功复现出来，我们记录一下trampoline偶尔会莫名为0这个现象，然后给qemu多打几个LOG，记录之继续推进
```
[Qemu] Agent will jump to twin_entry! With scause 8000000000000001
[Qemu] env->pc: ffffffff80a338d0
[QEMU] Agent call invoked at pc: 3f65c12168

[QEMU] Aret invoked at pc: ffffffff80a296d2 with nacc_sstatus: 200004020 nacc_state: 2d46f31f3f021
[QEMU] SET nacc_state to AGENT mode. nacc process in linux state, and the user trap.
[Qemu] Linux will return to 0
```
然后主线任务上，由于被替换的页表页本身并不存在对应的老页，也并不存在原本就已经分配好了的struct page*数据结构，因此出现了一些差错，具体来说好像确实是在`__pte_offset_map_lock`函数出的问题
- __pte_offset_map得到了正确的pte的值
- 但是pte_lockptr是有问题的，根据*pmd，也就是pmd中存储的PTE的值，去找`__pfn_to_page`中的`struct page*`数据结构，而这个数据结构没有被声明，因此会有问题！