## 实验记录
似乎卡在了__set_pte_at位置上，我们仔细看看

```C
static inline void __set_pte_at(struct mm_struct *mm, pte_t *ptep, pte_t pteval)
{
	if (pte_present(pteval) && pte_exec(pteval))
		flush_icache_pte(mm, pteval);

	set_pte(ptep, pteval);
}

/*
 * Certain architectures need to do special things when PTEs within
 * a page table are directly modified.  Thus, the following hook is
 * made available.
 */
static inline void set_pte(pte_t *ptep, pte_t pteval)
{
	WRITE_ONCE(*ptep, pteval);
}
```
这边的问题看起来是，在我这边让linux来代理agent处理页表页异常时，对于机密内存页表页进行了一个写的操作，即这边的WRITE_ONCE