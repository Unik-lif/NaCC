## 实验记录
似乎在linux中，不同情况下的线性地址空间是一致的，因此我们直接去找这个PMP区域所对应的线性虚拟地址空间就行，然后就能通过tval来确认，这个虚拟地址空间其实就是页表页区域了！

这件事情已经解决，虚拟地址相对还是比较固定的，因此很容易找到位置，然后让monitor代劳，程序继续往下走，现在运行到这里
```
[  206.570664] epc : ffffffff8018f44e ra : ffffffff8018f210 sp : ffffffc6007337d0
[  206.570738]  gp : ffffffff81718d68 tp : ffffffd687978cc0 t0 : 0000000000000000
[  206.570886]  t1 : 0000000000000000 t2 : 0000000000dc0e08 s0 : ffffffc6007338f0
[  206.570938]  s1 : 00000000488ef05b a0 : ffffffc50288ef00 a1 : 0000000000010000
[  206.570988]  a2 : 0000000100000000 a3 : 0000000000000000 a4 : 0000000000080000
[  206.571053]  a5 : 0000000000000000 a6 : 0000000000000001 a7 : 0000000000004c45
[  206.571103]  s2 : ffffffd73fffd080 s3 : 0000000000011000 s4 : 0000000000011000
[  206.571154]  s5 : ffffffc50288ef00 s6 : ffffffc50288ef00 s7 : ffffffc600733910
[  206.571204]  s8 : 7c00000000000000 s9 : 0000000000001000 s10: 0000000000010000
[  206.571255]  s11: ffffffc6007339d8 t3 : ffffffd69edbca60 t4 : 000000009837f050
[  206.571302]  t5 : 000000000000006b t6 : 0000000000006cc0
[  206.571349] status: 0000000200000120 badaddr: ffffffd73fffd080 cause: 0000000000000007
[  206.571641] [<ffffffff8018f44e>] unmap_page_range+0x584/0xac8
[  206.571931] [<ffffffff8018f9ca>] unmap_single_vma.isra.0+0x38/0x5e
[  206.571970] [<ffffffff8018fa70>] unmap_vmas+0x80/0x176
[  206.572006] [<ffffffff8019aa9e>] exit_mmap+0xb2/0x272
[  206.572043] [<ffffffff80010932>] mmput+0x52/0xf2
[  206.572088] [<ffffffff80018be0>] do_exit+0x1ba/0x77a
[  206.572122] [<ffffffff80019314>] do_group_exit+0x1c/0x8e
[  206.572156] [<ffffffff8001939c>] pid_child_should_wake+0x0/0x5c
[  206.572191] [<ffffffff80a29518>] do_trap_ecall_u+0x182/0x266
```
这里看起来是我们新添加的一种情况没有被纳入unmap_page_range时的一种情况中的考虑，

哦，这个有可能是系统调用的问题，这边毕竟调用了新的系统调用，需要给他加上新的状态类型，否则确实可能没有办法正常处理清楚