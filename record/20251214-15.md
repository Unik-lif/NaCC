## 实验记录
花了一些时间，跑起来了hello world，这是一个单进程程序，但是还有很多疑点没有解决
- 具体有多少系统调用涉及了内存的变化需要特殊的处理
    - 这个可能需要去跑其他的应用程序，慢慢落实他们
- 是否每一次page fault都得到了正确的处理
    - 看起来好像确实正确地处理了
- 销毁页表页内存的时候，opensbi这边的状态是怎么样的
- 为什么销毁的时候似乎是卡住了，不知道具体卡在了什么地方

我们已经知道的消息
- 如果我们要给用户态新添加内存，只是修改页表页内容，那么一定会触发page fault，因此这部分不会出问题
    - 修改存在老页表页对应关系的新页表页的内容，这种情况已经在hello world中覆盖到了
    - 但是新添加页表页的情况，尚还没有遇到
- 如果我们要去销毁内存的页表页，那么反而不会触发page fault
    - 先前的实现是先释放真正的页，然后根据被替换的末级页表页的对应关系，找到原有的末级页表页，Linux可以正常释放原有的页表页，并记录替换用的新的末级页表页
    - 然后依次向上寻找原有页表页并释放之，记录替换用的新页表页
    - exit的末端，对页表页通过flush方式，调用opensbi，进行释放
- 我们新引入的问题（15号再思考）
    - 我们在hello world环节修改了替换用的末级页表页的值，在尝试free这一部分页表页的时候，会根据先前我们已经记录的VMA来执行
    - 在zap_present_ptes环节中会对替换前的项进行清空，让其与后续真正的页断联
    - 我们新写值的位置，对应在替换前的页表页项，同样会被清空，这个操作应该是合理的
    - 但是，链接在新页表页上的物理内存页，并没有得到释放，我们先前锚定并且释放掉的是老页表页这边的


我们跟踪
```
..0: pte 6ffff801 pa 1bfffe000 [level 2]
.. ..0: pte 6ffff401 pa 1bfffd000 [level 1]
..255: pte 6ffff001 pa 1bfffc000 [level 2]
.. ..163: pte 6fffec01 pa 1bfffb000 [level 1]
```