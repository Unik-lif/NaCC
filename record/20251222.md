## 实验记录
```shell
# Transferred
..0: pte 6ffff801 pa 1bfffe000 [level 2]
.. ..0: pte 6ffff401 pa 1bfffd000 [level 1]
..255: pte 6ffff001 pa 1bfffc000 [level 2]
.. ..421: pte 6fffec01 pa 1bfffb000 [level 1]

[Summary] Page Table Pages Used:
  Level 2 (VPN[2]) pages: 1
  Level 1 (VPN[1]) pages: 2
  Level 0 (VPN[0]) pages: 2
  Total page table pages: 5 (size = 20 KiB)
  Total leaf data pages: 0 (bitmap size = 0 bytes)
  Total user leaf pages: 2

# Add Agent region
..0: pte 6ffff801 pa 1bfffe000 [level 2]
.. ..0: pte 6ffff401 pa 1bfffd000 [level 1]
..254: pte 6ffffc01 pa 1bffff000 [level 2]
.. ..206: pte 6fffe801 pa 1bfffa000 [level 1]
..255: pte 6ffff001 pa 1bfffc000 [level 2]
.. ..421: pte 6fffec01 pa 1bfffb000 [level 1]
[Summary] Page Table Pages Used:
  Level 2 (VPN[2]) pages: 1
  Level 1 (VPN[1]) pages: 3
  Level 0 (VPN[0]) pages: 3
  Total page table pages: 7 (size = 28 KiB)
  Total leaf data pages: 8 (bitmap size = 1 bytes)
  Total user leaf pages: 2

# Add user_context region, which will share user context between agent and linux


# 第一块释放的区域: 1bfffe000->1bfffd000 (1bfffd080)
# 第二块释放的区域: 1bfffe000->1bfffd000 (1bfffd088)
# 第三块释放的区域: 1bffff000->1bfff9000 ()
```
观察到诡异现象，在exit_mmap函数位置，明明此时进程对应的地址空间并不大，但是到了后续的unmap_vmas位置，突然这个地址空间变得特别大！我们明明是销毁地址空间的，反而出现了页表地址空间空前增长的现象！

11bf8d000

这个可能才是我们遇到的根源问题，昨天停住的地方可能是问题的表象

重要现象
```shell
page table 107a8d000
..0: pte 6ffff801 pa 1bfffe000 [level 2]
.. ..0: pte 6ffff401 pa 1bfffd000 [level 1]
..253: pte 6ffffc01 pa 1bffff000 [level 2]
.. ..342: pte 6fffe801 pa 1bfffa000 [level 1]
..254: pte 6fffe401 pa 1bfff9000 [level 2]
.. ..86: pte 6fffe001 pa 1bfff8000 [level 1]
..255: pte 6ffff001 pa 1bfffc000 [level 2]
.. ..218: pte 6fffec01 pa 1bfffb000 [level 1]

# zap_pte_range，尝试释放地址空间的时候，居然打印的是这个完全不一样的东西
# 启示：

# Breakpoint 2, zap_pte_range (tlb=<optimized out>, vma=0xffffffd68b1e1ed8, pmd=0xffffffd73fffe000,
#    addr=65536, end=69632, details=0xffffffc6007138e0) at /home/link/NaCC/linux/mm/memory.c:1686
# 1686                        pgtbl_debug();

# 进程tp可能是同一个，但是操作的这个地址空间的人，可能并不是从satp寄存器上可以读取的？
page table 105709000
..170: pte 415d2401 pa 105749000 [level 2]
.. ..419: pte 415d2001 pa 105748000 [level 1]
..254: pte 415b8001 pa 1056e0000 [level 2]
.. ..126: pte 41a98401 pa 106a61000 [level 1]
.. ..127: pte 42a81401 pa 10aa05000 [level 1]
.. ..128: pte 42c6c401 pa 10b1b1000 [level 1]
.. ..129: pte 41ece001 pa 107b38000 [level 1]
.. ..130: pte 415e0001 pa 105780000 [level 1]
.. ..134: pte 415d8801 pa 105762000 [level 1]
.. ..135: pte 41516c01 pa 10545b000 [level 1]
.. ..136: pte 415a1801 pa 105686000 [level 1]
.. ..137: pte 41573001 pa 1055cc000 [level 1]
.. ..138: pte 415bf801 pa 1056fe000 [level 1]
.. ..139: pte 415afc01 pa 1056bf000 [level 1]
.. ..140: pte 415b7c01 pa 1056df000 [level 1]
..255: pte 41565801 pa 105596000 [level 2]
.. ..324: pte 4156b401 pa 1055ad000 [level 1]
```

我全懂了，这是exit系统调用的锅，得仔细看看研究研究！