## 实验记录
为了更好知道具体是哪些系统调用被调用了，我们需要对linux这边打上其他更多的新log出来

具体哪些系统调用被使用了，因为有glibc和runc runtime的封装，我们并不能直观地从代码中获取，因此打印出来具体的这些系统调用名称，可能还是一件比较重要的事情

搞定

之后，我们尝试更深刻理解我们打印出来的系统调用exit_group
```C
/*
 * Turn us into a lazy TLB process if we
 * aren't already..
 */
static void exit_mm(void)
{
	struct mm_struct *mm = current->mm;

	exit_mm_release(current, mm);
	if (!mm)
		return;
	mmap_read_lock(mm);
	mmgrab_lazy_tlb(mm);
	BUG_ON(mm != current->active_mm);
	/* more a memory barrier than a real lock */
	task_lock(current);
	/*
	 * When a thread stops operating on an address space, the loop
	 * in membarrier_private_expedited() may not observe that
	 * tsk->mm, and the loop in membarrier_global_expedited() may
	 * not observe a MEMBARRIER_STATE_GLOBAL_EXPEDITED
	 * rq->membarrier_state, so those would not issue an IPI.
	 * Membarrier requires a memory barrier after accessing
	 * user-space memory, before clearing tsk->mm or the
	 * rq->membarrier_state.
	 */
	smp_mb__after_spinlock();
	local_irq_disable();
    // 当前进程主动切断了与自己mm的联系
    // 这样就能变成一个内核线程性质的实体，系统会发现它没有mm
    // 本质上是一个惰性TLB优化
	current->mm = NULL;
	membarrier_update_current_mm(NULL);
	enter_lazy_tlb(mm, current);
	local_irq_enable();
	task_unlock(current);
	mmap_read_unlock(mm);
	mm_update_next_owner(mm);
	mmput(mm);
	if (test_thread_flag(TIF_MEMDIE))
		exit_oom_victim();
}
```
对于linux进程的地址空间打印操作，我们得换一个接口来做!

现在的表示是正常的了，我们可以慢慢去debug，确认每一个user page都能得到正确的释放

由于这个释放程序它有可能被调度走，调试起来非常的不方便
- 首先，我们确实观察到了new pte被清除掉
- 其次，我们观测到其疑似尝试释放linux页表页，这显得很违和
    - 为什么会有这个现象
    - 并不是因为我们引入了新的页表页处理方式导致的，改成老的一样有这个问题，只不过先前qemu这边打的log太多，让我没有意识到这边有这个问题！
- 由于地址所处位置比较敏感，我们需要

```
level: 2, vaddr: 3f92efc000
[SBI] sec_mem_alloc allocated page at pa: 1bffff000
level: 1, vaddr: 3f92efc000
[SBI] sec_mem_alloc allocated page at pa: 1bfffa000
level: 2, vaddr: 3f92efd000
level: 1, vaddr: 3f92efd000
level: 2, vaddr: 3f92efe000
level: 1, vaddr: 3f92efe000
level: 2, vaddr: 3f92eff000
level: 1, vaddr: 3f92eff000
level: 2, vaddr: 3f92f00000
level: 1, vaddr: 3f92f00000
level: 2, vaddr: 3f92f01000
level: 1, vaddr: 3f92f01000
level: 2, vaddr: 3f92f02000
level: 1, vaddr: 3f92f02000
level: 2, vaddr: 3f92f03000
level: 1, vaddr: 3f92f03000
[SBI] Linux mapped agent region [3f92efc000, 3f92f04000]
```
花了很大的功夫，gdb给我跟了一天！终于找到问题所在了！！！

这个问题是因为在agent这边分配页表页的时候，由于是explicit分配的页表，并没有去尝试替换原本的页表页，所以在做锁操作的时候，新分配的页表页通过mappings，找到的actual_pfn这边找不到其所对应的page数据结构，所以访问就出了错误

关键函数
```C
static inline struct page *pmd_page_nacc(pmd_t pmd)
{
    unsigned long actual_pfn;
	actual_pfn = pmd_page_nacc_mappings(pmd);
    return pfn_to_page(actual_pfn);
}
```
解决方案：
- 需要搞清楚linux如何注册并分配struct page*数据结构，需要让opensbi这边和它统一起来
- 我们当前出错的位置，应该是agent和linux共享的内存，这个页应该是有对应的页表页的，可以尝试找找
- linux启动的时候疑似是可以给全部的页都打上struct page，但是我对此不是很确定，而且就算都做了分配，也不一定做了初始化，这部分还需要再确认再看看！