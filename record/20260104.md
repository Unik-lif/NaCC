## 实验记录 - busybox echo调试
这一次卡住的位置是
```
[  211.275709] [Linux]: 'do_page_fault' pt_regs details:
[  211.276116] [Linux]: 'do_page_fault' regs: 0xffffffc60069b8b0
[  211.276508] [Linux]: 'do_page_fault' status: 0x200000120
[  211.276856] [Linux]: 'do_page_fault' badaddr: 0xffffffc4fe000028
[  211.277229] [Linux]: 'do_page_fault' cause: 0xd
[  211.277541] [Linux]: 'do_page_fault' orig_a0: 0x200000120
[  211.277956] [Linux]: Back to 'do_irq' in kernel. With regs->status: 200000120
[  211.278659] [Linux]: Back to 'do_irq' in kernel. With regs->status: 200000120
[  211.279752] Unable to handle kernel paging request at virtual address ffffffc4fe000028
[  211.281180] Oops [#1]
[  211.281511] Modules linked in: veth xt_conntrack xt_MASQUERADE br_netfilter bridge stp llc nft_chain_nat nf_nat nf_conntrack xt_addrtype nft_compat xfrm_user xfrm_algo overlay 8021q drm drm_panel_orientatio
n_quirks configfs backlight ip_tables x_tables
[  211.286290] CPU: 0 UID: 0 PID: 735 Comm: echo Tainted: G        W          6.12.0-00010-g62503f7814b9-dirty #1
```

之前出问题的地方
```
0xffffffc4fe000028

0xffffffc600663bb0

0x2ace58f040
```

需要为每一次出现page fault的位置打上对应的页表位置信息，用来判断其对应的页表页存在的位置


解决了昨天卡住的问题，今天卡在了这里
```
[  281.915960] Unable to handle kernel paging request at virtual address ffffffc4fe000008
[  281.917329] Oops [#1]
[  281.917612] Modules linked in: veth xt_conntrack xt_MASQUERADE br_netfilter bridge stp llc nft_chain_nat nf_nat nf_conntrack xt_addrtype nft_compat xfrm_user xfrm_algo overlay 8021q drm drm_panel_orientatio
n_quirks configfs backlight ip_tables x_tables
[  281.922304] CPU: 0 UID: 0 PID: 802 Comm: echo Tainted: G        W          6.12.0-00010-g62503f7814b9-dirty #1
[  281.923366] Tainted: [W]=WARN
[  281.923646] Hardware name: riscv-virtio,qemu (DT)
[  281.924233] epc : follow_page_pte+0xc6/0x646
[  281.926210]  ra : follow_page_pte+0xb2/0x646
[  281.926573] epc : ffffffff8018817c ra : ffffffff80188168 sp : ffffffc6006a3420
[  281.927060]  gp : ffffffff81718d68 tp : ffffffd685773300 t0 : 0000000000000002
[  281.927547]  t1 : 0000000000000000 t2 : ffffffc6006a3440 s0 : ffffffc6006a3480
[  281.928014]  s1 : 0000003fbd117000 a0 : ffffffc4fe000000 a1 : 0000003fbd117000
[  281.928498]  a2 : 0000000000000000 a3 : 0000000000000000 a4 : ffffffd73fffb8b8
[  281.928991]  a5 : ffffffc4fe000000 a6 : ffffffd687c88d00 a7 : ffffffd687c88d48
[  281.929480]  s2 : 000000000000000e s3 : ffffffd687d85260 s4 : 0000000000000002
[  281.929947]  s5 : 0040000000000053 s6 : ffffffc6006a34b8 s7 : 0000000000000000
[  281.930440]  s8 : 0000000000000000 s9 : 0000000000000000 s10: ffffffc6006a354c
[  281.930909]  s11: 0000000000000000 t3 : 0000000000000001 t4 : ffffffd687c88d0c
[  281.931463]  t5 : 0000000000000000 t6 : 0000003fbd119fff
[  281.931830] status: 0000000200000120 badaddr: ffffffc4fe000008 cause: 000000000000000d
[  281.932580] [<ffffffff8018817c>] follow_page_pte+0xc6/0x646
[  281.933227] [<ffffffff80188b14>] __get_user_pages+0x418/0xc82
[  281.933613] [<ffffffff8018b7e0>] get_dump_page+0x4a/0xba
[  281.933961] [<ffffffff80253660>] dump_user_range+0x3c/0x1a4
[  281.934344] [<ffffffff8024b2a8>] elf_core_dump+0xa80/0xc50
[  281.934702] [<ffffffff802531b6>] do_coredump+0xe48/0x12b6
[  281.935061] [<ffffffff80024c34>] get_signal+0x56a/0x6d4
[  281.935427] [<ffffffff80004a42>] arch_do_signal_or_restart+0x50/0x5b2
[  281.935837] [<ffffffff80a2a0f4>] irqentry_exit_to_user_mode+0x6c/0x132
[  281.936268] [<ffffffff80a2949a>] do_trap_load_fault+0x46/0xd2
[  281.936644] [<ffffffff80a3411a>] _new_vmalloc_restore_context_a0+0xc2/0xce
[  281.937558] Code: 7693 0019 3703 fa84 87aa e6ed f613 004a 8b63 1c07 (6788) 7713
[  281.938528] [Linux]: Back to 'do_irq' in kernel. With regs->status: 200000120
[  281.939046] ---[ end trace 0000000000000000 ]---
[  281.939749] note: echo[802] exited with preempt_count 2
```

会崩的代码部分
```
ffffffff8018817c
ffffffff801a1fd0
```

观察到的问题
- 仔细检查了一下页表页分布情况，发现在busybox的场景下，存在在用户态区域新分配页表页的情况，可能是出现了页表页分配由OS来操作的情况，而这是不被我们所允许的
- 地址ffffffc4fe000008本质上是struct page*所对应的起始位置，这说明在攫取某一个pfn_to_page的结构的时候，出现了pfn输入为0的情况，而这个原因有可能是多样的，我们得尝试先找到该问题发生的位置

273767628800


调试方法：
- 可能需要在follow_page_pte位置多尝试打印一点信息出来