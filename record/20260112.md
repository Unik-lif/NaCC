## 实验记录
观测到struct page*得到了一定的初始化，存在这个metadata区域

但是，部分区域，尤其是经由opensbi进行分配的区域，对应的lock似乎并没有能够存在，对应位置是pad2，这边也可以从lock中看到

```
[  168.201313] [pmd_page_nacc]: pmd: 6ffff401 pfn: 1bfffd actual_pfn: 11bc65
[  168.201720] desc: ffffffc5026f1940 pmd: ffffffc600673360 *pmd pfn: 1bfffd *pmd: 6ffff401 lock: ffffffd6883c4e88
[  168.202581] [Linux]: Back to 'do_irq' in kernel. With regs->status: 200000120
[  168.203043] desc details: flags: 4000000000000000 pad1: 0 mapping: 0 index: 0 pad2: ffffffd6883c4e88 type: f2000000 ref: 1
[Qemu] nacc linux state pa: 1bfffc6a8 access_type: 0 pmp_has_privs: 1
[  168.210610] [pmd_page_nacc]: pmd: 6ffffc01 pfn: 1bffff actual_pfn: 1bffff
[  168.211113] desc: ffffffc504ffffc0 pmd: ffffffc600673360 *pmd pfn: 1bffff *pmd: 6ffffc01 lock: 0
[  168.211616] desc details: flags: 4000000000002000 pad1: ffffffc504ffffc8 mapping: 0 index: 0 pad2: 0 type: ffffffff ref: 1
[  168.212428] [Linux]: 'do_page_fault' pt_regs details:
[  168.212740] [Linux]: 'do_page_fault' regs: 0xffffffc600673200
[  168.213095] [Linux]: 'do_page_fault' status: 0x200000120
[  168.213418] [Linux]: 'do_page_fault' badaddr: 0x4
[  168.213711] [Linux]: 'do_page_fault' badaddr vpn[2]: 0 vpn[1]: 0 vpn[0]: 0
[  168.214122] [Linux]: 'do_page_fault' cause: 0xd
[  168.214439] [Linux]: 'do_page_fault' orig_a0: 0x0
[  168.214914] [Linux]: Back to 'do_irq' in kernel. With regs->status: 200000120
[  168.215371] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000004
```

结论
- 我们reserved区域并没有纳入到buddy system中，这个是很自然的，这样才能将其与linux可使用的内存分割开来
- 然而，在buddy system尝试分配空间的时候，会顺带尝试对对应的struct page进行更多设置和初始化，同时分配spinlock
- 因此，在opensbi分配了一些位于reserved区域的页时，需要让linux这边对其进行类似的初始化，关键是把锁给他拿到

这里需要解决两个问题
- 少量的来自于opensbi分配的页，需要经过linux来进行struct page的特殊位置的初始化，这个直接由opensbi送进去交给linux来进行处理就可以了，可能不是那么的麻烦
- 多数的来自于自己尝试分配机密内存页表页的尝试，这一步可能需要在关键路径上，通知opensbi来进行分配和修改页表页，然后返回的时候再在linux这边完成注册的工作

阅读pagetable_alloc_noprof代码发现可能涉及的比较多，但是也许它们并不是特别重要，如果只是给opensbi来用的话，也许我们可以先把显然会出问题的情况给他设置上，然后再考虑别的事情